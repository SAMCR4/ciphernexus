<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ciphernexus | E2E Secure Comm</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    
    <!-- PeerJS (WebRTC Signaling) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- QR Code Generator -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <!-- QR Code Scanner -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        nexus: {
                            dark: '#050510',
                            panel: 'rgba(20, 20, 35, 0.7)',
                            neon: '#00f3ff',
                            purple: '#bc13fe',
                            success: '#00ff9d',
                            danger: '#ff0055'
                        }
                    },
                    fontFamily: {
                        mono: ['Courier New', 'monospace'],
                        sans: ['Segoe UI', 'Roboto', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        /* Cyberpunk / Glassmorphism Base Styles */
        body {
            background-color: #020205;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(188, 19, 254, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(0, 243, 255, 0.1) 0%, transparent 20%);
            color: #e0e0e0;
            overflow: hidden; 
        }

        .glass-panel {
            background: rgba(20, 20, 35, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .neon-border {
            box-shadow: 0 0 5px rgba(0, 243, 255, 0.2), inset 0 0 5px rgba(0, 243, 255, 0.1);
            border: 1px solid rgba(0, 243, 255, 0.3);
        }
        
        .neon-text {
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
        }

        .btn-primary {
            background: linear-gradient(90deg, #00f3ff 0%, #bc13fe 100%);
            color: #000;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn-primary:hover {
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
            transform: translateY(-1px);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(0, 243, 255, 0.3); border-radius: 3px; }

        /* Animations */
        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .scan-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, transparent, rgba(0, 243, 255, 0.1), transparent);
            animation: scanline 4s linear infinite;
            pointer-events: none;
            z-index: 50;
        }

        /* Video Grid */
        .video-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
        }
        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>
<body class="h-screen w-screen text-sm">

    <!-- APP CONTAINER -->
    <div id="app" class="relative h-full w-full flex flex-col items-center justify-center">

        <!-- LOGIN SCREEN -->
        <div id="login-screen" class="absolute z-50 w-full h-full flex items-center justify-center bg-nexus-dark">
            <div class="scan-overlay"></div>
            <div class="glass-panel p-8 rounded-2xl w-96 max-w-[90%] flex flex-col gap-6 relative z-10">
                <div class="text-center">
                    <h1 class="text-3xl font-bold font-mono text-white tracking-wider neon-text">CIPHERNEXUS</h1>
                    <p class="text-xs text-nexus-neon mt-2 opacity-80">E2E ENCRYPTED // ZERO SERVER</p>
                </div>
                
                <div class="space-y-4">
                    <div>
                        <label class="text-xs text-gray-400 font-mono">AGENT ID (NICKNAME)</label>
                        <input type="text" id="nickname-input" class="w-full bg-black/50 border border-gray-700 rounded p-3 text-white focus:border-nexus-neon outline-none transition" placeholder="Enter alias...">
                    </div>
                    <div>
                        <label class="text-xs text-gray-400 font-mono">SESSION KEY (PASSWORD)</label>
                        <input type="password" id="password-input" class="w-full bg-black/50 border border-gray-700 rounded p-3 text-white focus:border-nexus-purple outline-none transition" placeholder="Shared secret...">
                    </div>
                </div>

                <div class="space-y-3">
                    <button onclick="Nexus.initSession(false)" class="btn-primary w-full p-3 rounded shadow-lg">
                        <i class="fas fa-satellite-dish mr-2"></i> Init Session
                    </button>
                    <div class="text-center text-xs text-gray-500">- OR -</div>
                    <button onclick="Nexus.openScanner()" class="w-full border border-nexus-neon/50 text-nexus-neon p-3 rounded hover:bg-nexus-neon/10 transition">
                        <i class="fas fa-qrcode mr-2"></i> Scan Join Code
                    </button>
                </div>
            </div>
        </div>

        <!-- MAIN INTERFACE (Hidden initially) -->
        <div id="main-ui" class="hidden w-full h-full flex flex-col md:flex-row overflow-hidden relative">
            
            <!-- LEFT SIDEBAR -->
            <div class="w-full md:w-64 glass-panel flex flex-col border-r border-gray-800 z-20">
                <div class="p-4 border-b border-gray-800 flex justify-between items-center">
                    <h2 class="font-mono font-bold text-nexus-neon">NEXUS LINK</h2>
                    <div id="connection-status" class="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_red]"></div>
                </div>
                
                <!-- User List -->
                <div class="flex-1 overflow-y-auto p-4 space-y-3" id="user-list">
                    <!-- Users injected here -->
                    <div class="text-xs text-gray-500 italic">Waiting for peers...</div>
                </div>

                <!-- Session Info -->
                <div class="p-4 bg-black/20 border-t border-gray-800 text-xs font-mono space-y-2">
                    <div class="flex justify-between">
                        <span class="text-gray-400">MY ID:</span>
                        <span id="my-peer-id-display" class="text-white truncate w-24 cursor-pointer" onclick="Nexus.copyToClipboard(this.innerText)">...</span>
                    </div>
                    <button onclick="Nexus.showQR()" class="w-full bg-gray-800 hover:bg-gray-700 text-white p-2 rounded flex items-center justify-center gap-2">
                        <i class="fas fa-qrcode"></i> Show Join QR
                    </button>
                    <div class="flex gap-2">
                         <input type="text" id="remote-peer-input" placeholder="Enter Peer ID to Join" class="w-full bg-black border border-gray-700 rounded p-1 text-white">
                         <button onclick="Nexus.connectToPeer()" class="bg-nexus-neon text-black px-2 rounded"><i class="fas fa-plug"></i></button>
                    </div>
                </div>
            </div>

            <!-- CENTER: CHAT & VIDEO -->
            <div class="flex-1 flex flex-col bg-nexus-dark/80 relative">
                
                <!-- Video Grid -->
                <div id="video-grid" class="hidden flex-wrap gap-2 p-2 bg-black/40 min-h-[200px] border-b border-gray-800">
                    <!-- Local Video -->
                    <div id="local-video-container" class="video-container w-48 border border-nexus-neon">
                        <video id="local-video" muted autoplay playsinline></video>
                        <div class="absolute bottom-1 left-1 text-xs bg-black/70 px-1 text-nexus-neon">YOU</div>
                    </div>
                </div>

                <!-- Chat Area -->
                <div id="chat-box" class="flex-1 overflow-y-auto p-4 space-y-4 scroll-smooth">
                    <!-- Messages go here -->
                    <div class="flex justify-center my-4">
                        <span class="text-xs text-nexus-success bg-nexus-success/10 px-3 py-1 rounded-full border border-nexus-success/30">
                            <i class="fas fa-shield-alt mr-1"></i> End-to-End Encrypted
                        </span>
                    </div>
                </div>

                <!-- Input Area -->
                <div class="p-4 glass-panel border-t border-gray-800">
                    <div id="file-progress-container" class="hidden mb-2">
                         <div class="flex justify-between text-xs text-nexus-neon mb-1">
                             <span id="file-status-text">Uploading...</span>
                             <span id="file-percent">0%</span>
                         </div>
                         <div class="w-full bg-gray-800 h-1 rounded overflow-hidden">
                             <div id="file-bar" class="bg-nexus-neon h-full w-0 transition-all duration-300"></div>
                         </div>
                    </div>

                    <form onsubmit="Nexus.sendMessage(event)" class="flex gap-3">
                        <label class="cursor-pointer text-gray-400 hover:text-nexus-neon flex items-center">
                            <i class="fas fa-paperclip text-lg"></i>
                            <input type="file" id="file-input" class="hidden" onchange="Nexus.handleFileUpload(this)">
                        </label>
                        <input type="text" id="msg-input" class="flex-1 bg-black/50 border border-gray-700 rounded-full px-4 text-white focus:border-nexus-neon outline-none" placeholder="Encrypted message..." autocomplete="off">
                        <button type="submit" class="text-nexus-neon hover:text-white transition">
                            <i class="fas fa-paper-plane text-lg"></i>
                        </button>
                    </form>
                </div>

                <!-- Floating Video Controls -->
                <div class="absolute top-4 right-4 flex gap-2">
                    <button onclick="Nexus.toggleVideo()" id="btn-video" class="glass-panel w-10 h-10 rounded-full flex items-center justify-center text-gray-400 hover:text-white hover:border-nexus-neon transition">
                        <i class="fas fa-video"></i>
                    </button>
                    <button onclick="Nexus.toggleAudio()" id="btn-audio" class="glass-panel w-10 h-10 rounded-full flex items-center justify-center text-gray-400 hover:text-white hover:border-nexus-neon transition">
                        <i class="fas fa-microphone"></i>
                    </button>
                </div>
            </div>

        </div>

        <!-- MODALS -->
        
        <!-- QR Display Modal -->
        <div id="qr-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm" onclick="Nexus.closeModals()">
            <div class="glass-panel p-6 rounded-xl flex flex-col items-center gap-4 animate-bounce-in" onclick="event.stopPropagation()">
                <h3 class="text-nexus-neon font-mono text-lg">SESSION QR</h3>
                <div id="qr-code-display" class="bg-white p-2 rounded"></div>
                <p class="text-xs text-gray-400 text-center max-w-[250px]">
                    Scan to join. Contains PeerID & Salt.<br>
                    <span class="text-red-400">Room password must be entered manually.</span>
                </p>
                <button onclick="Nexus.closeModals()" class="text-xs border border-gray-600 px-4 py-1 rounded hover:bg-gray-800">CLOSE</button>
            </div>
        </div>

        <!-- QR Scanner Modal -->
        <div id="scan-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/90" onclick="Nexus.stopScanner()">
            <div class="w-full h-full flex flex-col items-center justify-center relative" onclick="event.stopPropagation()">
                <canvas id="qr-canvas" class="rounded-lg border-2 border-nexus-neon shadow-[0_0_20px_#00f3ff] max-w-[90%]"></canvas>
                <div class="absolute bottom-10 bg-black/60 px-4 py-2 rounded text-white font-mono animate-pulse">Scanning Camera Stream...</div>
                <button onclick="Nexus.stopScanner()" class="absolute top-4 right-4 text-white text-2xl"><i class="fas fa-times"></i></button>
            </div>
        </div>

    </div>

    <!-- MAIN LOGIC -->
    <script>
        /**
         * CIPHERNEXUS CORE LOGIC
         * 1. CRYPTO: PBKDF2 Key Derivation, AES-GCM Encryption
         * 2. NETWORK: PeerJS Signaling + DataChannel
         * 3. UI: View Management
         */

        const Nexus = {
            state: {
                nick: '',
                password: '',
                keyMaterial: null,   // Imported password key
                masterKey: null,     // AES-GCM Key
                peer: null,          // PeerJS instance
                conn: null,          // DataConnection
                call: null,          // MediaConnection
                localStream: null,
                peers: {},           // Connected peers
                files: {}            // File transfer state
            },

            // --- 1. CRYPTOGRAPHY MODULE ---

            // Derive a master AES-GCM key from password and salt
            async deriveKey(password, saltString = 'nexus_default_salt') {
                const enc = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
                );
                
                // Using PBKDF2 instead of Argon2 to keep file standalone (Argon2 requires WASM file)
                const key = await window.crypto.subtle.deriveKey(
                    {
                        name: "PBKDF2",
                        salt: enc.encode(saltString),
                        iterations: 100000,
                        hash: "SHA-256"
                    },
                    keyMaterial,
                    { name: "AES-GCM", length: 256 },
                    false,
                    ["encrypt", "decrypt"]
                );
                return key;
            },

            async encrypt(data) {
                if (!this.state.masterKey) return null;
                const enc = new TextEncoder();
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encodedData = typeof data === 'string' ? enc.encode(data) : data;
                
                const ciphertext = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    this.state.masterKey,
                    encodedData
                );

                // Pack IV + Ciphertext
                const buffer = new Uint8Array(iv.byteLength + ciphertext.byteLength);
                buffer.set(iv, 0);
                buffer.set(new Uint8Array(ciphertext), iv.byteLength);
                return buffer; // Returns Uint8Array
            },

            async decrypt(buffer) {
                if (!this.state.masterKey) return null;
                try {
                    const iv = buffer.slice(0, 12);
                    const data = buffer.slice(12);
                    
                    const decrypted = await window.crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: iv },
                        this.state.masterKey,
                        data
                    );
                    return decrypted;
                } catch (e) {
                    console.error("Decryption failed", e);
                    return null;
                }
            },

            // --- 2. INITIALIZATION ---

            async initSession(isJoin = false) {
                const nick = document.getElementById('nickname-input').value;
                const pass = document.getElementById('password-input').value;

                if (!nick || !pass) {
                    alert("Nickname and Password required.");
                    return;
                }

                this.state.nick = nick;
                this.state.password = pass;

                // UI Transition
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('main-ui').classList.remove('hidden');
                
                // Init Crypto
                this.state.masterKey = await this.deriveKey(pass);

                // Init PeerJS
                // We use a random ID, but can share it via QR
                this.state.peer = new Peer(null, {
                    debug: 2
                });

                this.state.peer.on('open', (id) => {
                    document.getElementById('my-peer-id-display').innerText = id;
                    this.appendSystemMessage(`System initialized. Your ID: ${id}`);
                    this.updateStatus(true);
                });

                this.state.peer.on('connection', (conn) => {
                    this.handleIncomingConnection(conn);
                });

                this.state.peer.on('call', (call) => {
                    this.handleIncomingCall(call);
                });

                this.state.peer.on('error', (err) => {
                    console.error(err);
                    this.appendSystemMessage(`Network Error: ${err.type}`);
                });
            },

            // --- 3. CONNECTION LOGIC ---

            connectToPeer(targetId = null) {
                const peerId = targetId || document.getElementById('remote-peer-input').value;
                if (!peerId) return;

                this.appendSystemMessage(`Connecting to ${peerId}...`);
                
                const conn = this.state.peer.connect(peerId);
                this.setupConnection(conn);
            },

            setupConnection(conn) {
                conn.on('open', async () => {
                    this.state.conn = conn;
                    this.appendSystemMessage(`Connected to peer. Handshake secure.`);
                    this.updateStatus(true, 'connected');
                    
                    // Send Greeting
                    const payload = JSON.stringify({ type: 'handshake', nick: this.state.nick });
                    const encrypted = await this.encrypt(payload);
                    conn.send(encrypted);
                });

                conn.on('data', async (data) => {
                    await this.handleData(data);
                });

                conn.on('close', () => {
                    this.appendSystemMessage("Peer disconnected.");
                    this.updateStatus(false);
                });
            },

            handleIncomingConnection(conn) {
                this.state.conn = conn;
                this.setupConnection(conn);
            },

            async handleData(arrayBuffer) {
                // Check if buffer is valid
                if (!(arrayBuffer instanceof ArrayBuffer) && !(arrayBuffer instanceof Uint8Array)) {
                    // It might be a blob or other format
                    if (arrayBuffer instanceof Blob) {
                         arrayBuffer = await arrayBuffer.arrayBuffer();
                    }
                }
                
                const decrypted = await this.decrypt(new Uint8Array(arrayBuffer));
                
                if (!decrypted) {
                    this.appendSystemMessage("Warning: Received undecryptable packet. Wrong password?");
                    return;
                }

                const dec = new TextDecoder();
                // Try to parse as JSON first
                let msgObj = null;
                let rawText = null;

                try {
                    rawText = dec.decode(decrypted);
                    msgObj = JSON.parse(rawText);
                } catch (e) {
                    // Binary file data likely
                }

                if (msgObj) {
                    if (msgObj.type === 'chat') {
                        this.appendMessage(msgObj.nick, msgObj.text, false);
                    } else if (msgObj.type === 'handshake') {
                        this.appendSystemMessage(`User ${msgObj.nick} verified.`);
                        this.addSidebarUser(msgObj.nick);
                    } else if (msgObj.type === 'file-start') {
                        this.startFileReceive(msgObj);
                    } else if (msgObj.type === 'file-chunk') {
                        this.receiveFileChunk(msgObj);
                    }
                }
            },

            // --- 4. MESSAGING ---

            async sendMessage(e) {
                e.preventDefault();
                const input = document.getElementById('msg-input');
                const text = input.value;
                if (!text || !this.state.conn) return;

                const payload = JSON.stringify({ type: 'chat', nick: this.state.nick, text: text });
                const encrypted = await this.encrypt(payload);
                
                this.state.conn.send(encrypted);
                this.appendMessage('ME', text, true);
                input.value = '';
            },

            appendMessage(nick, text, isMe) {
                const box = document.getElementById('chat-box');
                const div = document.createElement('div');
                div.className = `flex flex-col ${isMe ? 'items-end' : 'items-start'}`;
                
                const bubble = document.createElement('div');
                bubble.className = `max-w-[80%] p-3 rounded-lg ${isMe ? 'bg-nexus-purple text-white rounded-br-none' : 'bg-gray-800 border border-gray-700 text-gray-200 rounded-bl-none'}`;
                bubble.innerHTML = `<div class="text-[10px] opacity-70 mb-1 font-mono">${nick}</div><div>${this.escapeHtml(text)}</div>`;
                
                div.appendChild(bubble);
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            },

            appendSystemMessage(text) {
                const box = document.getElementById('chat-box');
                const div = document.createElement('div');
                div.className = 'text-center my-2';
                div.innerHTML = `<span class="text-xs text-nexus-neon font-mono bg-nexus-neon/10 px-2 py-1 rounded border border-nexus-neon/20">${text}</span>`;
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            },

            // --- 5. FILE TRANSFER (CHUNKED + ENCRYPTED) ---

            async handleFileUpload(input) {
                const file = input.files[0];
                if (!file || !this.state.conn) return;

                // 1. Notify Receiver
                const metaPayload = JSON.stringify({
                    type: 'file-start',
                    name: file.name,
                    size: file.size,
                    mime: file.type,
                    nick: this.state.nick
                });
                this.state.conn.send(await this.encrypt(metaPayload));

                this.appendSystemMessage(`Sending ${file.name}...`);
                document.getElementById('file-progress-container').classList.remove('hidden');

                // 2. Chunk & Send
                const chunkSize = 16384; // 16KB safe limit for DataChannel
                let offset = 0;
                const reader = new FileReader();

                reader.onload = async (e) => {
                    const chunkBuffer = e.target.result;
                    // In real app, we encrypt binary chunks. For simplicity, we base64 encode then encrypt as JSON
                    // to reuse existing encryption wrapper, though less efficient.
                    // Better: Encrypt ArrayBuffer directly.
                    
                    // Let's stick to base64 for reliable JSON transport in this demo
                    const b64 = this.arrayBufferToBase64(chunkBuffer);
                    
                    const chunkPayload = JSON.stringify({
                        type: 'file-chunk',
                        data: b64,
                        offset: offset
                    });
                    
                    this.state.conn.send(await this.encrypt(chunkPayload));
                    
                    offset += chunkBuffer.byteLength;
                    this.updateProgressBar(offset, file.size);

                    if (offset < file.size) {
                        readNextChunk();
                    } else {
                        // Done
                        setTimeout(() => document.getElementById('file-progress-container').classList.add('hidden'), 2000);
                        this.appendSystemMessage(`Sent ${file.name}`);
                    }
                };

                const readNextChunk = () => {
                    const slice = file.slice(offset, offset + chunkSize);
                    reader.readAsArrayBuffer(slice);
                };

                readNextChunk();
            },

            startFileReceive(meta) {
                this.state.files['current'] = {
                    meta: meta,
                    received: 0,
                    buffer: []
                };
                this.appendSystemMessage(`Receiving ${meta.name} from ${meta.nick}...`);
                document.getElementById('file-progress-container').classList.remove('hidden');
                document.getElementById('file-status-text').innerText = "Downloading encrypted stream...";
            },

            receiveFileChunk(chunkData) {
                const current = this.state.files['current'];
                if(!current) return;

                // Decode base64 to bytes
                const bytes = this.base64ToArrayBuffer(chunkData.data);
                current.buffer.push(bytes);
                current.received += bytes.byteLength;

                this.updateProgressBar(current.received, current.meta.size);

                if (current.received >= current.meta.size) {
                    this.finalizeFile(current);
                    this.state.files['current'] = null;
                }
            },

            finalizeFile(fileData) {
                const blob = new Blob(fileData.buffer, { type: fileData.meta.mime });
                const url = URL.createObjectURL(blob);
                
                const box = document.getElementById('chat-box');
                const div = document.createElement('div');
                div.className = 'flex justify-center my-2';
                div.innerHTML = `
                    <div class="bg-gray-800 border border-gray-600 p-3 rounded flex items-center gap-3">
                        <i class="fas fa-file-download text-nexus-neon text-xl"></i>
                        <div>
                            <div class="text-white font-bold text-sm">${this.escapeHtml(fileData.meta.name)}</div>
                            <a href="${url}" download="${fileData.meta.name}" class="text-xs text-nexus-neon underline">Download Decrypted File</a>
                        </div>
                    </div>
                `;
                box.appendChild(div);
                document.getElementById('file-progress-container').classList.add('hidden');
            },

            // --- 6. VIDEO/AUDIO CALLS ---

            async toggleVideo() {
                if (!this.state.localStream) await this.startMedia();
                const videoTrack = this.state.localStream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('btn-video').classList.toggle('text-nexus-neon');
            },

            async toggleAudio() {
                if (!this.state.localStream) await this.startMedia();
                const audioTrack = this.state.localStream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('btn-audio').classList.toggle('text-nexus-neon');
            },

            async startMedia() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    this.state.localStream = stream;
                    
                    const localVideo = document.getElementById('local-video');
                    localVideo.srcObject = stream;
                    document.getElementById('video-grid').classList.remove('hidden');
                    document.getElementById('video-grid').classList.add('flex');
                    document.getElementById('btn-video').classList.add('text-nexus-neon');
                    document.getElementById('btn-audio').classList.add('text-nexus-neon');

                    // Call peer if connected
                    if (this.state.conn) {
                         // Note: PeerJS handles WebRTC SRTP encryption (standard DTLS)
                         // Our extra layer encrypted the signaling of this call, but not the media bytes themselves 
                         // (doing JS-based media encryption is too slow). 
                         // However, WebRTC is secure by default.
                         const call = this.state.peer.call(this.state.conn.peer, stream);
                         this.handleMediaCall(call);
                    }
                } catch (e) {
                    console.error("Media Error", e);
                    alert("Could not access camera/mic");
                }
            },

            handleIncomingCall(call) {
                // Answer automatically if we are in a trusted session (simplified)
                navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) => {
                    this.state.localStream = stream;
                    document.getElementById('local-video').srcObject = stream;
                    document.getElementById('video-grid').classList.remove('hidden');
                    document.getElementById('video-grid').classList.add('flex');

                    call.answer(stream); // Answer the call with an A/V stream.
                    this.handleMediaCall(call);
                }).catch(err => {
                    console.error('Failed to get local stream', err);
                });
            },

            handleMediaCall(call) {
                this.state.call = call;
                call.on('stream', (remoteStream) => {
                    // Check if video element exists
                    let remoteVideo = document.getElementById('remote-video');
                    if (!remoteVideo) {
                        const container = document.createElement('div');
                        container.className = 'video-container w-48 border border-nexus-purple';
                        container.innerHTML = `<video id="remote-video" autoplay playsinline></video><div class="absolute bottom-1 left-1 text-xs bg-black/70 px-1 text-nexus-purple">REMOTE</div>`;
                        document.getElementById('video-grid').appendChild(container);
                        remoteVideo = container.querySelector('video');
                    }
                    remoteVideo.srcObject = remoteStream;
                });
            },

            // --- 7. QR & UTILS ---

            showQR() {
                const modal = document.getElementById('qr-modal');
                modal.classList.remove('hidden');
                document.getElementById('qr-code-display').innerHTML = "";
                
                // Data for QR: Just the PeerID. Password must be known.
                // We could embed password, but that reduces security if QR is seen.
                // Spec says: "Room room code... derived key fingerprint"
                // We will put: "nexus://join?id=" + peerId
                const qrData = JSON.stringify({
                    id: this.state.peer.id,
                    nick: this.state.nick
                });

                new QRCode(document.getElementById("qr-code-display"), {
                    text: qrData,
                    width: 128,
                    height: 128
                });
            },

            openScanner() {
                document.getElementById('scan-modal').classList.remove('hidden');
                this.startScanning();
            },

            startScanning() {
                const video = document.createElement("video");
                const canvasElement = document.getElementById("qr-canvas");
                const canvas = canvasElement.getContext("2d");
                
                navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then((stream) => {
                    this.scannerStream = stream;
                    video.srcObject = stream;
                    video.setAttribute("playsinline", true);
                    video.play();
                    requestAnimationFrame(tick);
                });

                const tick = () => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvasElement.height = video.videoHeight;
                        canvasElement.width = video.videoWidth;
                        canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
                        const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "dontInvert" });
                        
                        if (code) {
                            try {
                                const data = JSON.parse(code.data);
                                if (data.id) {
                                    this.stopScanner();
                                    document.getElementById('remote-peer-input').value = data.id;
                                    // Auto close scan modal, user enters pass
                                    alert(`Found Peer: ${data.nick || 'Unknown'}. Enter password to join.`);
                                    document.getElementById('login-screen').classList.remove('hidden'); // Back to login to enter pass
                                }
                            } catch(e) { console.log("Invalid QR"); }
                        }
                    }
                    if(!document.getElementById('scan-modal').classList.contains('hidden')) {
                         requestAnimationFrame(tick);
                    }
                };
            },

            stopScanner() {
                document.getElementById('scan-modal').classList.add('hidden');
                if (this.scannerStream) {
                    this.scannerStream.getTracks().forEach(track => track.stop());
                }
            },

            closeModals() {
                document.getElementById('qr-modal').classList.add('hidden');
            },

            // --- HELPERS ---
            updateStatus(online, type) {
                const el = document.getElementById('connection-status');
                if (online) {
                    el.classList.remove('bg-red-500', 'shadow-[0_0_10px_red]');
                    el.classList.add('bg-nexus-success', 'shadow-[0_0_10px_#00ff9d]');
                } else {
                    el.classList.add('bg-red-500', 'shadow-[0_0_10px_red]');
                    el.classList.remove('bg-nexus-success', 'shadow-[0_0_10px_#00ff9d]');
                }
            },
            
            addSidebarUser(nick) {
                const list = document.getElementById('user-list');
                const div = document.createElement('div');
                div.className = 'flex items-center gap-2 p-2 rounded bg-white/5 border border-white/10';
                div.innerHTML = `<div class="w-2 h-2 rounded-full bg-nexus-success"></div><span class="text-white">${this.escapeHtml(nick)}</span>`;
                // Clear "waiting" message if exists
                if(list.innerText.includes("Waiting")) list.innerHTML = '';
                list.appendChild(div);
            },

            updateProgressBar(current, total) {
                const percent = Math.floor((current / total) * 100);
                document.getElementById('file-bar').style.width = `${percent}%`;
                document.getElementById('file-percent').innerText = `${percent}%`;
            },

            escapeHtml(text) {
                const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
                return text.replace(/[&<>"']/g, function(m) { return map[m]; });
            },

            copyToClipboard(text) {
                navigator.clipboard.writeText(text);
                this.appendSystemMessage("ID Copied to Clipboard");
            },

            arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return window.btoa(binary);
            },

            base64ToArrayBuffer(base64) {
                const binary_string = window.atob(base64);
                const len = binary_string.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                return bytes.buffer;
            }
        };

        // Expose to window
        window.Nexus = Nexus;

    </script>
</body>
</html>