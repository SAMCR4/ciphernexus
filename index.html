<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nexus P2P — Chat + Encrypted Files + Video + ACKs</title>

<!-- Tailwind -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Font Awesome -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
<!-- GUN + SEA + WebRTC plugin + SimplePeer -->
<script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gun/lib/webrtc.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simple-peer@9/simplepeer.min.js"></script>

<style>
  body { background:#071026; color:#e6eef8; font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; padding:18px; }
  .glass { background: rgba(10,12,20,0.6); border-radius:12px; padding:14px; border:1px solid rgba(255,255,255,0.03); }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }
  .video-container { position: relative; background:#000; border-radius:8px; overflow:hidden; min-height:90px; display:flex; align-items:center; justify-content:center;}
  .video-container video { width:100%; height:100%; object-fit:cover; }
  .thumb { max-width:100px; max-height:70px; object-fit:cover; border-radius:6px; }
  .small { font-size:12px; }
  .btn { padding:8px 10px; border-radius:8px; cursor:pointer; }
  .badge { background:rgba(255,255,255,0.04); padding:4px 8px; border-radius:999px; font-size:12px; }
</style>
</head>
<body>
<div class="max-w-7xl mx-auto grid grid-cols-1 md:grid-cols-4 gap-6">
  <!-- left -->
  <div class="glass col-span-1 space-y-3">
    <h2 class="text-lg font-bold">NEXUS — P2P All-in-One</h2>
    <div class="small text-gray-300">No backend required — works on GitHub Pages</div>

    <label class="small block mt-3">Nickname</label>
    <input id="nick" class="w-full p-2 rounded bg-black/20 border border-gray-700" placeholder="alice"/>

    <label class="small block mt-2">Room ID</label>
    <input id="room" class="w-full p-2 rounded bg-black/20 border border-gray-700" placeholder="room-123"/>

    <label class="small block mt-2">Passkey</label>
    <input id="pass" type="password" class="w-full p-2 rounded bg-black/20 border border-gray-700" placeholder="shared secret"/>

    <div class="flex gap-2 mt-3">
      <button id="joinBtn" class="flex-1 btn bg-gradient-to-r from-sky-400 to-violet-600 text-black font-bold" onclick="Nexus.joinRoom()">Join</button>
      <button class="btn border" onclick="Nexus.leaveRoom()">Leave</button>
    </div>

    <div class="mt-3 small text-gray-300">
      <div>Peers: <span id="peerCount">0</span></div>
      <div>Messages: <span id="msgCount">0</span></div>
    </div>

    <div class="mt-3 small">
      <div class="font-semibold">Media</div>
      <div class="flex gap-2 mt-2">
        <button id="btnCamera" class="btn border" onclick="Nexus.toggleVideo()"><i class="fas fa-video"></i></button>
        <button id="btnMic" class="btn border" onclick="Nexus.toggleAudio()"><i class="fas fa-microphone"></i></button>
        <button id="btnHang" class="btn border" onclick="Nexus.stopMedia()">Hangup</button>
      </div>
    </div>

    <div class="mt-3 small">
      <div class="font-semibold">Files</div>
      <div id="dropArea" class="mt-2 p-3 border-2 border-dashed border-gray-700 rounded small text-gray-400">Drag & drop files here or use the picker</div>
      <input id="fileInput" type="file" class="mt-2"/>
      <div id="uploadProgress" class="mt-2 small hidden">
        <div id="uploadText"></div>
        <div class="w-full bg-gray-800 h-2 rounded mt-1"><div id="uploadBar" class="h-full" style="width:0%; background:linear-gradient(90deg,#00f3ff,#bc13fe)"></div></div>
      </div>
      <button class="btn border mt-2" onclick="Nexus.uploadSelectedFile()">Upload</button>
    </div>

    <div class="mt-3 small glass p-2 rounded" style="height:220px; overflow:auto;" id="logBox">
      &gt; Ready.
    </div>
  </div>

  <!-- center -->
  <div class="glass col-span-2 p-4 flex flex-col">
    <div class="flex justify-between items-center">
      <div>
        <div class="text-xs text-gray-400">Room</div>
        <div id="roomLabel" class="mono">—</div>
      </div>
      <div>
        <div class="text-xs text-gray-400">You</div>
        <div id="nickLabel" class="mono">—</div>
      </div>
    </div>

    <div id="videoGrid" class="grid grid-cols-2 gap-2 mt-3" style="min-height:160px"></div>

    <div id="chat" class="flex-1 overflow-auto mt-3 p-3 bg-black/10 rounded small" style="min-height:240px"></div>

    <div class="mt-3 flex gap-2">
      <input id="msgInput" class="flex-1 p-2 rounded bg-black/20 border border-gray-700" placeholder="Type a message..." disabled/>
      <button id="sendBtn" class="btn border" onclick="Nexus.sendMessage()" disabled><i class="fas fa-paper-plane"></i></button>
    </div>
    <div class="small text-gray-400 mt-1" id="typingIndicator"></div>
  </div>

  <!-- right -->
  <div class="glass col-span-1 p-4 space-y-3">
    <div>
      <div class="text-xs text-gray-400">Users</div>
      <div id="usersList" class="mt-2 small bg-black/10 rounded p-2" style="min-height:160px">—</div>
    </div>

    <div>
      <div class="text-xs text-gray-400">Files</div>
      <div id="filesList" class="mt-2 small bg-black/10 rounded p-2 overflow-auto" style="max-height:300px">—</div>
    </div>
  </div>
</div>

<script>
/* Nexus P2P — Combined: chat + file sharing + video + ordering + ACKs + resume
   - Uses GUN + SEA for P2P graph + signaling
   - Uses SimplePeer for media connections (signaling via GUN room signals)
   - Files chunked and stored under room/files/<fileId>/parts/<index> (encrypted)
   - Messages: encrypted (AES-GCM derived from passkey)
   - Ordering: per-sender seq stored in localStorage 'nexus_seq_<roomId>'
   - ACKs: stored under room/acks/<msgId>/<peerNick> = true
   - Dedup persistence: seen msgIds stored in localStorage 'nexus_seen_<roomId>'
*/

const Nexus = {
  gun: null,
  roomNode: null,
  nick: null, roomId: null, pass: null,
  aesKey: null, // CryptoKey AES-GCM
  seenMessages: new Set(),
  seqCounter: 0,
  peers: {},            // map: peerNick -> { simplePeer, remoteStream }
  myStreams: { local:null },
  fileChunkSize: 500*1024,
  ackRetries: {},       // msgId -> attempts
  MAX_RETRIES: 3,
  init() {
    // drag-n-drop
    const drop = document.getElementById('dropArea');
    drop.addEventListener('dragover', (e)=>{ e.preventDefault(); drop.classList.add('ring-1','ring-sky-400'); });
    drop.addEventListener('dragleave', ()=>{ drop.classList.remove('ring-1','ring-sky-400'); });
    drop.addEventListener('drop', (e)=>{ e.preventDefault(); drop.classList.remove('ring-1','ring-sky-400'); const f = e.dataTransfer.files[0]; if(f) { document.getElementById('fileInput').files = e.dataTransfer.files; } });
    // file input small UX
    document.getElementById('fileInput').addEventListener('change', ()=> { const f=document.getElementById('fileInput').files[0]; if(f && f.type.startsWith('image/')) this.previewImage(f); });
  },

  log(s) { const el = document.getElementById('logBox'); const d = document.createElement('div'); d.innerText = '> ' + s; el.appendChild(d); el.scrollTop = el.scrollHeight; console.log('[NEXUS]', s); },

  // crypto helpers (derive AES key from passkey)
  async deriveAESKey(pass) {
    const enc = new TextEncoder();
    const passBytes = enc.encode(pass + '|nexus_key_v2'); // pepper
    const hash = await crypto.subtle.digest('SHA-256', passBytes);
    return crypto.subtle.importKey('raw', hash, 'AES-GCM', false, ['encrypt','decrypt']);
  },
  arrayBufferToBase64(buf) { let binary=''; const bytes = new Uint8Array(buf); for(let i=0;i<bytes.length;i++) binary += String.fromCharCode(bytes[i]); return btoa(binary); },
  base64ToArrayBuffer(b64) { const binary = atob(b64); const len = binary.length; const bytes = new Uint8Array(len); for(let i=0;i<len;i++) bytes[i]=binary.charCodeAt(i); return bytes.buffer; },

  async encryptArrayBuffer(ab) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, this.aesKey, ab);
    const out = new Uint8Array(iv.byteLength + ct.byteLength);
    out.set(iv,0); out.set(new Uint8Array(ct), iv.byteLength);
    return this.arrayBufferToBase64(out.buffer);
  },
  async decryptArrayBuffer(b64) {
    const buf = this.base64ToArrayBuffer(b64);
    const iv = buf.slice(0,12); const data = buf.slice(12);
    const pt = await crypto.subtle.decrypt({ name:'AES-GCM', iv:new Uint8Array(iv) }, this.aesKey, data);
    return pt;
  },

  // local persistent store for seen msg ids and seq counter
  loadSeen() {
    try {
      const k = 'nexus_seen_' + (this.roomId || '');
      const raw = localStorage.getItem(k);
      if(raw) {
        const arr = JSON.parse(raw);
        arr.forEach(id => this.seenMessages.add(id));
      }
    } catch(e){}
  },
  saveSeen() {
    try {
      const k = 'nexus_seen_' + (this.roomId || '');
      localStorage.setItem(k, JSON.stringify(Array.from(this.seenMessages).slice(-5000)));
    } catch(e){}
  },
  loadSeq() {
    try {
      const k = 'nexus_seq_' + (this.roomId || '');
      const raw = localStorage.getItem(k);
      this.seqCounter = raw ? Number(raw) : 0;
    } catch(e){ this.seqCounter = 0; }
  },
  saveSeq() {
    try { localStorage.setItem('nexus_seq_' + this.roomId, String(this.seqCounter)); } catch(e){}
  },

  async joinRoom() {
    const nick = document.getElementById('nick').value.trim();
    const room = document.getElementById('room').value.trim();
    const pass = document.getElementById('pass').value;
    if(!nick||!room||!pass) { alert('Fill nick/room/pass'); return; }

    this.nick = nick; this.roomId = room; this.pass = pass;
    document.getElementById('nickLabel').innerText = this.nick;
    document.getElementById('roomLabel').innerText = this.roomId;

    this.log('Initializing GUN and joining room: ' + this.roomId);
    // init gun with public peers (can add more)
    this.gun = Gun({ peers: ['https://gun-manhattan.herokuapp.com/gun', 'https://gun-us.herokuapp.com/gun'] });

    this.aesKey = await this.deriveAESKey(this.pass);
    this.roomNode = this.gun.get('nexus-room::' + this.roomId);

    // load persisted seen & seq
    this.loadSeen(); this.loadSeq();

    // presence
    this.roomNode.get('presence').get(this.nick).put({ nick:this.nick, ts:Date.now() });

    // presence map subscribes
    this.roomNode.get('presence').map().on((v,k)=>this.renderUsers());

    // message map subscribes
    this.roomNode.get('messages').map().on(async (obj,id)=> {
      if(!obj || !obj.msgId || this.seenMessages.has(obj.msgId)) return;
      // ordering: store in temp buffer until sequence is contiguous per sender
      // but to keep code reasonably small we render as messages come (but we preserve dedupe + ack)
      try {
        const ab = await this.decryptArrayBuffer(obj.msg);
        const txt = new TextDecoder().decode(ab);
        this.seenMessages.add(obj.msgId);
        this.saveSeen();
        // send ACK
        this.roomNode.get('acks').get(obj.msgId).get(this.nick).put(true);
        // render
        this.renderMessage(obj.nick, txt, obj.msgId, obj.seq, obj.ts);
        // update counts
        this.updateCounts();
      } catch(e) {
        // ignore decrypt errors
      }
    });

    // acks subscription (optional for UI)
    this.roomNode.get('acks').map().on(()=>{ /* we don't render ack list, but sender watches her acks */ });

    // signals for SimplePeer stored under room/signals/<to>/<from> = data
    this.roomNode.get('signals').map().on((v, key) => {
      // key is mapping structure used by GUN; value contains objects keyed by 'from' etc.
      // We'll instead read signaling by querying per-peer signal channel when needed (see signal handler below)
    });

    // file list
    this.roomNode.get('files').map().on((meta,fileId)=>{
      if(!meta || !meta.name) return;
      this.renderFileEntry(fileId, meta);
    });

    // typing map
    this.roomNode.get('typing').map().on((t,k)=> { if(t && t.nick) { document.getElementById('typingIndicator').innerText = t.nick + ' is typing…'; setTimeout(()=>{ if(document.getElementById('typingIndicator').innerText.includes(t.nick)) document.getElementById('typingIndicator').innerText = ''; }, 1200); }});

    // setup signal listener: we use a channel under room/signals/<to>/<from> = { data }
    // listen to any signals targeted to us
    this.roomNode.get('signals').get(this.nick).map().on(async (obj, from) => {
      if(!obj || !obj.data) return;
      // obj.from = otherNick; obj.data = simple-peer signaling JSON (string)
      const fromNick = from;
      try {
        const data = obj.data;
        await this._handleSignal(fromNick, data);
      } catch(e){ console.warn('signal handle error', e); }
    });

    // enable UI
    document.getElementById('msgInput').disabled = false;
    document.getElementById('sendBtn').disabled = false;
    document.getElementById('fileInput').disabled = false;
    document.getElementById('fileInput').addEventListener('change', ()=>this.previewIfImage());

    this.log('Joined. Ready.');
    setTimeout(()=> this.renderUsers(), 800);
  },

  leaveRoom() {
    if(!this.roomNode) return;
    this.roomNode.get('presence').get(this.nick).put(null);
    this.roomNode = null;
    this.gun = null;
    document.getElementById('chat').innerHTML = '';
    document.getElementById('usersList').innerHTML = '';
    document.getElementById('filesList').innerHTML = '';
    this.log('Left room');
  },

  // MESSAGE SEND: includes seq, msgId, timestamp. Then watch for ACKs and retry if necessary.
  async sendMessage() {
    const el = document.getElementById('msgInput'); const text = el.value.trim(); if(!text || !this.roomNode) return;
    el.value = '';
    // seq
    this.seqCounter = (this.seqCounter || 0) + 1; this.saveSeq();
    const seq = this.seqCounter;
    const msgId = crypto.randomUUID();
    const ts = Date.now();
    const ab = new TextEncoder().encode(text);
    const b64 = await this.encryptArrayBuffer(ab.buffer);
    const obj = { nick:this.nick, msg:b64, ts, msgId, seq };
    this.roomNode.get('messages').set(obj);
    // store attempt data
    this.ackRetries[msgId] = 0;
    this._watchAcks(msgId, obj);
    // locally render immediately
    this.renderMessage(this.nick, text, msgId, seq, ts);
  },

  // watch acks: will retry re-broadcast up to MAX_RETRIES
  _watchAcks(msgId, obj) {
    const check = async () => {
      const acks = [];
      // read ack set once
      this.roomNode.get('acks').get(msgId).map().once((v,k)=>{
        if(v) acks.push(k);
      });
      // after slight delay evaluate
      setTimeout(async ()=>{
        // determine how many peers should ack (approx count of presence entries)
        let peerCount = 0;
        const presence = [];
        this.roomNode.get('presence').map().once((v,k)=>{ if(v && v.nick) presence.push(k); });
        peerCount = presence.length;
        // Exclude self
        peerCount = Math.max(0, peerCount - 1);
        const ackCount = acks.length;
        if(ackCount >= peerCount || peerCount === 0) {
          // all good
          delete this.ackRetries[msgId];
          return;
        } else {
          this.ackRetries[msgId] = (this.ackRetries[msgId] || 0) + 1;
          if(this.ackRetries[msgId] > this.MAX_RETRIES) {
            this.log(`Message ${msgId} not ACKed by ${peerCount - ackCount} peers after ${this.MAX_RETRIES} attempts.`);
            delete this.ackRetries[msgId];
            return;
          } else {
            // Re-broadcast
            this.log(`Retrying message ${msgId} (attempt ${this.ackRetries[msgId]})`);
            this.roomNode.get('messages').set(obj);
            setTimeout(check, 4000 + (this.ackRetries[msgId]*1000));
          }
        }
      }, 600);
    };
    setTimeout(check, 2000); // initial check after 2s
  },

  renderMessage(nick, text, msgId, seq, ts) {
    const c = document.getElementById('chat');
    const div = document.createElement('div');
    div.className = 'mb-2';
    div.innerHTML = `<div class="text-xs text-gray-400 mono">${this.escape(nick)} <span class="text-[10px] text-gray-500">· ${new Date(ts).toLocaleTimeString()}</span></div>
                     <div class="p-2 bg-black/20 rounded">${this.escape(text)}</div>`;
    c.appendChild(div); c.scrollTop = c.scrollHeight;
    // add to seen set and persist
    if(msgId) { this.seenMessages.add(msgId); this.saveSeen(); }
    this.updateCounts();
  },

  escape(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m])); },

  updateCounts() {
    // messages count
    let c = 0; this.roomNode.get('messages').map().once((v,id)=>{ if(v && v.msgId) c++; });
    setTimeout(()=> { document.getElementById('msgCount').innerText = c; }, 400);
    // peers count
    const usersDiv = document.getElementById('usersList'); setTimeout(()=> { document.getElementById('peerCount').innerText = usersDiv.children.length || 0; }, 250);
  },

  // typing
  sendTyping() {
    if(!this.roomNode) return;
    this.roomNode.get('typing').get(this.nick).put({ nick:this.nick, ts:Date.now() });
  },

  // USERS UI
  renderUsers() {
    const out = document.getElementById('usersList'); out.innerHTML = '';
    this.roomNode.get('presence').map().once((v,k)=>{ if(!v || !v.nick) return; const div=document.createElement('div'); div.className='flex justify-between items-center mb-1'; div.innerHTML = `<div class="mono">${this.escape(v.nick)}</div><div class="text-xs text-gray-400">${new Date(v.ts).toLocaleTimeString()}</div>`; out.appendChild(div); });
    this.updateCounts();
  },

  /* ---------------------
     Media handling with SimplePeer + signaling over GUN
     --------------------- */

  async toggleVideo() {
    if(this.myStreams.local && this.myStreams.local.getVideoTracks && this.myStreams.local.getVideoTracks()[0]) {
      const t = this.myStreams.local.getVideoTracks()[0]; t.enabled = !t.enabled; return;
    }
    await this.startMedia({video:true, audio:true});
  },

  async toggleAudio() {
    if(this.myStreams.local && this.myStreams.local.getAudioTracks && this.myStreams.local.getAudioTracks()[0]) {
      const t = this.myStreams.local.getAudioTracks()[0]; t.enabled = !t.enabled; return;
    }
    await this.startMedia({video:false, audio:true});
  },

  async startMedia(constraints={video:true, audio:true}) {
    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      this.myStreams.local = stream;
      this.addLocalVideo(stream);
      // initiate SimplePeer with each known presence peer
      // build simple peer for each found presence entry
      this.roomNode.get('presence').map().once((v,k)=> {
        if(!v || !v.nick || v.nick === this.nick) return;
        // create peer if missing
        if(!this.peers[v.nick]) this._createPeerFor(v.nick, true, stream);
      });
      // Also listen for new presence entries and create peers
      this.roomNode.get('presence').map().on((v,k) => {
        if(!v || !v.nick || v.nick === this.nick) return;
        if(!this.peers[v.nick]) this._createPeerFor(v.nick, true, stream);
      });
    } catch(e) { console.warn('media error', e); alert('Media denied or unavailable'); }
  },

  stopMedia() {
    if(this.myStreams.local) {
      this.myStreams.local.getTracks().forEach(t => t.stop());
      this.myStreams.local = null;
    }
    // destroy peers
    for(const p in this.peers) {
      try { this.peers[p].peer.destroy(); } catch(e) {}
      this.removeRemoteVideo(p);
    }
    this.peers = {};
  },

  addLocalVideo(stream) {
    // remove existing local preview if any
    const grid = document.getElementById('videoGrid'); let existing = document.getElementById('vlocal');
    if(existing) existing.srcObject = stream; else {
      const div = document.createElement('div'); div.className='video-container'; div.innerHTML = `<video id="vlocal" autoplay muted playsinline></video><div class="absolute left-2 bottom-2 px-2 py-1 bg-black/60 rounded text-xs">LOCAL</div>`;
      grid.prepend(div); div.querySelector('video').srcObject = stream;
    }
  },

  addRemoteVideo(stream, peerNick) {
    const id = 'r_' + peerNick;
    const grid = document.getElementById('videoGrid');
    let el = document.getElementById(id);
    if(el) { el.srcObject = stream; return; }
    const div = document.createElement('div'); div.className='video-container';
    div.innerHTML = `<video id="${id}" autoplay playsinline></video><div class="absolute left-2 bottom-2 px-2 py-1 bg-black/60 rounded text-xs">${this.escape(peerNick)}</div>`;
    grid.appendChild(div); div.querySelector('video').srcObject = stream;
  },

  removeRemoteVideo(peerNick) {
    const id = 'r_' + peerNick;
    const el = document.getElementById(id);
    if(el && el.parentNode) el.parentNode.remove();
  },

  // signaling channel handlers for SimplePeer
  async _createPeerFor(remoteNick, initiator, stream) {
    // create SimplePeer
    const p = new SimplePeer({ initiator: initiator, trickle: true, stream: stream || undefined });
    this.peers[remoteNick] = { peer: p, stream: null, remoteNick };
    p.on('signal', data => {
      // send signal via GUN under room/signals/<to>/<from> = { data }
      const payload = { data: JSON.stringify(data), from: this.nick, ts: Date.now() };
      this.roomNode.get('signals').get(remoteNick).get(this.nick).put(payload);
    });
    p.on('connect', () => { this.log('Peer connect: ' + remoteNick); });
    p.on('stream', s => {
      this.peers[remoteNick].stream = s;
      this.addRemoteVideo(s, remoteNick);
    });
    p.on('close', ()=> { this.log('Peer closed: ' + remoteNick); try{ p.destroy(); }catch(e){} delete this.peers[remoteNick]; this.removeRemoteVideo(remoteNick); });
    p.on('error', (e)=>{ console.warn('peer error', e); });
    return p;
  },

  // handle incoming signaling object from remote
  async _handleSignal(fromNick, dataStr) {
    // parse
    let data = dataStr;
    try { data = JSON.parse(dataStr); } catch(e){ /* maybe already object */ }
    // find peer instance; if not present create non-initiator (since remote signaled)
    if(!this.peers[fromNick]) {
      // create a non-initiator SimplePeer (will answer)
      this._createPeerFor(fromNick, false, this.myStreams.local || undefined).then(p=>{
        try { p.signal(data); } catch(e){ console.warn('signal apply failed', e); }
      });
    } else {
      try { this.peers[fromNick].peer.signal(data); } catch(e){ console.warn('signal apply failed', e); }
    }
  },

  /* -------------
     FILE UPLOAD with resume
     ------------- */

  previewIfImage() {
    const f = document.getElementById('fileInput').files[0];
    if(!f) return;
    this.previewImage(f);
  },

  previewImage(file) {
    if(!file.type.startsWith('image/')) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      // show preview in filesList temporarily
      const container = document.getElementById('filesList');
      const div = document.createElement('div'); div.className='mb-2';
      div.innerHTML = `<img src="${e.target.result}" class="thumb mr-2"/><div class="mono">${this.escape(file.name)} (${file.size} bytes)</div>`;
      container.prepend(div);
    };
    reader.readAsDataURL(file);
  },

  async uploadSelectedFile() {
    const fi = document.getElementById('fileInput');
    if(!fi.files || fi.files.length===0) { alert('Choose a file'); return; }
    const file = fi.files[0];
    if(!this.roomNode) { alert('Join room first'); return; }
    const total = file.size;
    const parts = Math.ceil(total / this.fileChunkSize);
    const fileId = crypto.randomUUID();
    this.log(`Uploading ${file.name} as ${fileId} (${parts} parts)`);

    // write metadata
    this.roomNode.get('files').get(fileId).put({ name:file.name, size:total, uploader:this.nick, created:Date.now(), parts });

    // resume: check which parts present
    const present = {};
    let presentCount = 0;
    for(let i=0;i<parts;i++){
      // using once to check if part exists
      this.roomNode.get('files').get(fileId).get('parts').get(i).once((p)=>{
        if(p && p.data) { present[i] = true; presentCount++; }
      });
    }
    // wait a bit for checks to return
    await new Promise(r=>setTimeout(r, 600));

    // start reading from first missing part
    let offset = 0; let idx = 0;
    while(idx < parts && present[idx]) { offset += Math.min(this.fileChunkSize, total - offset); idx++; }

    const reader = new FileReader();
    reader.onload = async (ev) => {
      const ab = ev.target.result;
      const b64 = await this.encryptArrayBuffer(ab);
      this.roomNode.get('files').get(fileId).get('parts').get(idx).put({ idx, data:b64, size:ab.byteLength });
      offset += ab.byteLength;
      idx++;
      // update UI
      const pct = Math.floor((offset/total)*100); document.getElementById('uploadBar').style.width = pct + '%'; document.getElementById('uploadText').innerText = `Uploading ${idx}/${parts} (${pct}%)`;
      if(offset < total) {
        const slice = file.slice(offset, offset + this.fileChunkSize);
        reader.readAsArrayBuffer(slice);
      } else {
        document.getElementById('uploadText').innerText = `Upload complete`;
        setTimeout(()=>{ document.getElementById('uploadBar').style.width='0%'; document.getElementById('uploadText').innerText=''; }, 1200);
        this.log('Upload finished: ' + file.name);
      }
    };
    reader.onerror = (e)=> this.log('Read error ' + e);

    // start from idx
    const firstSlice = file.slice(offset, offset + this.fileChunkSize);
    document.getElementById('uploadProgress').classList.remove('hidden');
    reader.readAsArrayBuffer(firstSlice);
  },

  // Render file entry in UI
  renderFileEntry(fileId, meta) {
    if(!meta || !meta.name) return;
    // avoid duplicates
    if(document.querySelector(`[data-file="${fileId}"]`)) return;
    const container = document.getElementById('filesList');
    const el = document.createElement('div'); el.setAttribute('data-file', fileId); el.className='mb-2 p-2 border rounded bg-black/5';
    el.innerHTML = `<div class="font-semibold mono">${this.escape(meta.name)}</div><div class="text-xs text-gray-400">by ${this.escape(meta.uploader || 'anon')} — ${meta.size || '?'} bytes</div>
      <div class="mt-1"><button class="btn border" onclick="Nexus.downloadFile('${fileId}')">Download</button></div>`;
    container.prepend(el);
  },

  async downloadFile(fileId) {
    this.log('Downloading ' + fileId);
    // read meta
    this.roomNode.get('files').get(fileId).once(async (meta)=>{
      if(!meta || !meta.parts) { this.log('No meta/parts'); return; }
      const parts = meta.parts;
      const buffers = [];
      let got = 0;
      for(let i=0;i<parts;i++){
        ((idx)=>{
          this.roomNode.get('files').get(fileId).get('parts').get(idx).once(async (p)=>{
            if(!p || !p.data) { this.log('Missing part ' + idx); return; }
            try {
              const dec = await this.decryptArrayBuffer(p.data);
              buffers[idx] = new Uint8Array(dec);
              got++;
              if(got === parts) {
                // assemble
                let totalLen = buffers.reduce((s,b)=>s+b.length,0);
                const all = new Uint8Array(totalLen); let pos=0; for(const b of buffers){ all.set(b,pos); pos+=b.length; }
                const blob = new Blob([all]);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = meta.name || ('file-'+fileId); document.body.appendChild(a); a.click(); a.remove();
                URL.revokeObjectURL(url);
                this.log('File ready: '+meta.name);
              }
            } catch(e){ this.log('Decrypt part failed (wrong passkey?)'); }
          });
        })(i);
      }
    });
  },

  // SIGNAL helper for debugging: dumps signals to console (not required)
  dumpSignals() { this.roomNode.get('signals').map().once((v,k)=>console.log('signal entry',k,v)); }
};

// small init
Nexus.init();
window.Nexus = Nexus;

// wire some UI shortcuts
document.getElementById('msgInput').addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey) { Nexus.sendMessage(); e.preventDefault(); } });
document.getElementById('msgInput').addEventListener('input', ()=> Nexus.sendTyping());

</script>
</body>
</html>