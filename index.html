<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Encrypted Room</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
/* Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
}

body {
  background: #0d0d0d;
  color: #eee;
  font-family: Arial, sans-serif;
  overflow: hidden;
}

/* Background theme */
#bg {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at 30% 20%, #222, #000);
  z-index: -1;
}

/* Draggable windows */
.window {
  position: absolute;
  background: rgba(20,20,20,0.85);
  backdrop-filter: blur(10px);
  border: 1px solid #555;
  border-radius: 8px;
  padding: 10px;
  width: 350px;
  height: 260px;
  overflow: hidden;
  cursor: default;
  box-shadow: 0 0 15px rgba(0,0,0,0.5);
}

.window-header {
  font-size: 14px;
  font-weight: bold;
  padding-bottom: 6px;
  cursor: grab;
  color: #ccc;
}

.window-content {
  width: 100%;
  height: calc(100% - 28px);
  overflow-y: auto;
}

/* Chat window */
#chatLog {
  width: 100%;
  height: 85%;
  overflow-y: auto;
  font-size: 13px;
  padding-right: 5px;
}

#chatInput {
  width: 100%;
  padding: 6px;
  margin-top: 5px;
  background: #111;
  border: 1px solid #444;
  color: white;
  outline: none;
  border-radius: 5px;
}

/* Video windows */
video {
  width: 100%;
  height: 100%;
  background: black;
  border-radius: 6px;
}

/* Button bar */
#controls {
  position: fixed;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(20,20,20,0.7);
  padding: 8px 14px;
  border-radius: 8px;
  border: 1px solid #555;
  display: flex;
  gap: 10px;
}

.ctrl-btn {
  padding: 6px 12px;
  background: #222;
  border: 1px solid #666;
  border-radius: 6px;
  color: #eee;
  cursor: pointer;
  font-size: 14px;
}
.ctrl-btn:hover {
  background: #333;
}

/* User counter bubble */
#userCountBubble {
  position: fixed;
  top: 10px;
  right: 10px;
  background: rgba(40,40,40,0.8);
  padding: 8px 12px;
  border-radius: 6px;
  border: 1px solid #777;
  font-size: 14px;
}

/* Loading overlay */
#loader {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  color: #ddd;
  z-index: 2000;
}
</style>
</head>

<body>
<div id="bg"></div>

<div id="loader">Loading encrypted room…</div>

<!-- Video windows -->
<div class="window" id="localWindow" style="top:20px; left:20px;">
  <div class="window-header">Your Video</div>
  <div class="window-content">
    <video id="localVideo" autoplay muted playsinline></video>
  </div>
</div>

<div class="window" id="remoteWindow" style="top:20px; right:20px;">
  <div class="window-header">Remote Video</div>
  <div class="window-content">
    <video id="remoteVideo" autoplay playsinline></video>
  </div>
</div>

<!-- Chat window -->
<div class="window" id="chatWindow" style="bottom:80px; left:20px; height:300px;">
  <div class="window-header">Encrypted Chat</div>
  <div class="window-content">
    <div id="chatLog"></div>
    <input id="chatInput" placeholder="Type encrypted message…" />
  </div>
</div>

<!-- User counter -->
<div id="userCountBubble">Users: 0</div>

<!-- Controls -->
<div id="controls">
  <button class="ctrl-btn" id="toggleMute">Mute</button>
  <button class="ctrl-btn" id="toggleVideo">Video</button>
  <button class="ctrl-btn" id="shareScreen">Share Screen</button>
</div>
<script>
// ======== CONFIG ========
const SUPABASE_URL = "https://kljdpxtheqywenuycrgc.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtsamRweHRoZXF5d2VudXljcmdjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4MDc1MTMsImV4cCI6MjA4MDM4MzUxM30.ZqYXnJ6utRXpZTT2o81APRKk3J-IaOgBXIc8YBV9P-0";

// ======== GLOBALS ========
let supabaseClient;
let roomKey = null;
let roomId = null;
let encryptionKey = null;

let pc; // WebRTC PeerConnection
let localStream;
let remoteStream;

let dragging = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

const windows = ["localWindow", "remoteWindow", "chatWindow"];

// ======== UTILS ========
function $(id) { return document.getElementById(id); }

// Random room ID fallback
function randomRoomId() {
  return "room-" + Math.random().toString(36).slice(2, 10);
}

// Derive AES key from passphrase
async function deriveKey(pass) {
  const enc = new TextEncoder().encode(pass);
  const hash = await crypto.subtle.digest("SHA-256", enc);
  const key = await crypto.subtle.importKey(
    "raw", hash, { name: "AES-GCM" },
    false, ["encrypt", "decrypt"]
  );
  return key;
}

// Crypto wrappers
async function encryptObj(obj) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const data = new TextEncoder().encode(JSON.stringify(obj));
  const cipher = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    encryptionKey,
    data
  );
  return {
    iv: Array.from(iv),
    cipher: btoa(String.fromCharCode(...new Uint8Array(cipher)))
  };
}

async function decryptObj(payload) {
  try {
    const iv = new Uint8Array(payload.iv);
    const cipherBytes = Uint8Array.from(atob(payload.cipher), c => c.charCodeAt(0));
    const plain = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      encryptionKey,
      cipherBytes
    );
    return JSON.parse(new TextDecoder().decode(plain));
  } catch (e) {
    return null;
  }
}

// ======== SUPABASE INIT ========
async function initSupabase() {
  supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  supabaseClient
    .channel(roomId)
    .on("postgres_changes", { event: "*", schema: "public", table: "signals" }, handleSignal)
    .subscribe();

  supabaseClient
    .channel(roomId + "-presence")
    .on("presence", { event: "sync" }, updatePresence)
    .on("presence", { event: "join" }, updatePresence)
    .on("presence", { event: "leave" }, updatePresence)
    .subscribe(async (status) => {
      if (status === "SUBSCRIBED") {
        await supabaseClient.channel(roomId + "-presence").track({ user: true });
      }
    });
}

// ======== PRESENCE ========
async function updatePresence() {
  const pres = await supabaseClient.channel(roomId + "-presence").presenceState();
  const count = Object.keys(pres).length;
  $("userCountBubble").innerText = "Users: " + count;
}

// ======== SIGNAL HANDLING ========
async function sendSignal(type, data) {
  const encrypted = await encryptObj({ type, data });
  await supabaseClient.from("signals").insert({
    room_id: roomId,
    payload: encrypted
  });
}

async function handleSignal(event) {
  const payload = event.new.payload;
  const msg = await decryptObj(payload);
  if (!msg) return;

  if (msg.type === "offer") {
    await pc.setRemoteDescription(msg.data);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    sendSignal("answer", answer);
  }

  if (msg.type === "answer") {
    await pc.setRemoteDescription(msg.data);
  }

  if (msg.type === "ice") {
    pc.addIceCandidate(msg.data);
  }

  if (msg.type === "chat") {
    appendChat("[Remote] " + msg.data);
  }

  if (msg.type === "pos") {
    const { id, x, y } = msg.data;
    const w = $(id);
    if (w) {
      w.style.left = x + "px";
      w.style.top = y + "px";
    }
  }
}

// ======== CHAT ========
function appendChat(msg) {
  const log = $("chatLog");
  log.innerHTML += `<div>${msg}</div>`;
  log.scrollTop = log.scrollHeight;
}

$("chatInput").addEventListener("keydown", async e => {
  if (e.key === "Enter" && $("chatInput").value.trim()) {
    const msg = $("chatInput").value.trim();
    $("chatInput").value = "";
    appendChat("[You] " + msg);
    sendSignal("chat", msg);
  }
});

// ======== DRAGGABLE WINDOWS ========
windows.forEach(id => {
  const el = $(id);
  const header = el.querySelector(".window-header");

  header.addEventListener("mousedown", e => {
    dragging = el;
    dragOffsetX = e.clientX - el.offsetLeft;
    dragOffsetY = e.clientY - el.offsetTop;
  });
});

window.addEventListener("mouseup", () => dragging = null);

window.addEventListener("mousemove", e => {
  if (!dragging) return;
  const x = e.clientX - dragOffsetX;
  const y = e.clientY - dragOffsetY;
  dragging.style.left = x + "px";
  dragging.style.top = y + "px";

  sendSignal("pos", { id: dragging.id, x, y });
});

// ======== WEBRTC ========
async function initWebRTC() {
  pc = new RTCPeerConnection({
    iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }]
  });

  remoteStream = new MediaStream();
  $("remoteVideo").srcObject = remoteStream;

  pc.ontrack = e => {
    remoteStream.addTrack(e.track);
  };

  pc.onicecandidate = e => {
    if (e.candidate) sendSignal("ice", e.candidate);
  };

  localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
  $("localVideo").srcObject = localStream;

  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  sendSignal("offer", offer);
}

// ======== CONTROLS ========
$("toggleMute").addEventListener("click", () => {
  localStream.getAudioTracks().forEach(t => t.enabled = !t.enabled);
});

$("toggleVideo").addEventListener("click", () => {
  localStream.getVideoTracks().forEach(t => t.enabled = !t.enabled);
});

$("shareScreen").addEventListener("click", async () => {
  const scr = await navigator.mediaDevices.getDisplayMedia({ video: true });
  const screenTrack = scr.getVideoTracks()[0];
  const sender = pc.getSenders().find(s => s.track.kind === "video");
  sender.replaceTrack(screenTrack);
});

// ======== ROOM INIT ========
async function startApp() {
  roomId = prompt("Enter room ID:", randomRoomId());
  roomKey = prompt("Enter shared secret password:");

  encryptionKey = await deriveKey(roomKey);

  await initSupabase();
  await initWebRTC();

  $("loader").style.display = "none";
}

startApp();
// ======== CONFIG ========
const SUPABASE_URL = "https://kljdpxtheqywenuycrgc.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtsamRweHRoZXF5d2VudXljcmdjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4MDc1MTMsImV4cCI6MjA4MDM4MzUxM30.ZqYXnJ6utRXpZTT2o81APRKk3J-IaOgBXIc8YBV9P-0";

// ======== GLOBALS ========
let supabaseClient;
let roomKey = null;
let roomId = null;
let encryptionKey = null;

let pc; // WebRTC PeerConnection
let localStream;
let remoteStream;

let dragging = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

const windows = ["localWindow", "remoteWindow", "chatWindow"];

// ======== UTILS ========
function $(id) { return document.getElementById(id); }

// Random room ID fallback
function randomRoomId() {
  return "room-" + Math.random().toString(36).slice(2, 10);
}

// Derive AES key from passphrase
async function deriveKey(pass) {
  const enc = new TextEncoder().encode(pass);
  const hash = await crypto.subtle.digest("SHA-256", enc);
  const key = await crypto.subtle.importKey(
    "raw", hash, { name: "AES-GCM" },
    false, ["encrypt", "decrypt"]
  );
  return key;
}

// Crypto wrappers
async function encryptObj(obj) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const data = new TextEncoder().encode(JSON.stringify(obj));
  const cipher = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    encryptionKey,
    data
  );
  return {
    iv: Array.from(iv),
    cipher: btoa(String.fromCharCode(...new Uint8Array(cipher)))
  };
}

async function decryptObj(payload) {
  try {
    const iv = new Uint8Array(payload.iv);
    const cipherBytes = Uint8Array.from(atob(payload.cipher), c => c.charCodeAt(0));
    const plain = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      encryptionKey,
      cipherBytes
    );
    return JSON.parse(new TextDecoder().decode(plain));
  } catch (e) {
    return null;
  }
}

// ======== SUPABASE INIT ========
async function initSupabase() {
  supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  supabaseClient
    .channel(roomId)
    .on("postgres_changes", { event: "*", schema: "public", table: "signals" }, handleSignal)
    .subscribe();

  supabaseClient
    .channel(roomId + "-presence")
    .on("presence", { event: "sync" }, updatePresence)
    .on("presence", { event: "join" }, updatePresence)
    .on("presence", { event: "leave" }, updatePresence)
    .subscribe(async (status) => {
      if (status === "SUBSCRIBED") {
        await supabaseClient.channel(roomId + "-presence").track({ user: true });
      }
    });
}

// ======== PRESENCE ========
async function updatePresence() {
  const pres = await supabaseClient.channel(roomId + "-presence").presenceState();
  const count = Object.keys(pres).length;
  $("userCountBubble").innerText = "Users: " + count;
}

// ======== SIGNAL HANDLING ========
async function sendSignal(type, data) {
  const encrypted = await encryptObj({ type, data });
  await supabaseClient.from("signals").insert({
    room_id: roomId,
    payload: encrypted
  });
}

async function handleSignal(event) {
  const payload = event.new.payload;
  const msg = await decryptObj(payload);
  if (!msg) return;

  if (msg.type === "offer") {
    await pc.setRemoteDescription(msg.data);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    sendSignal("answer", answer);
  }

  if (msg.type === "answer") {
    await pc.setRemoteDescription(msg.data);
  }

  if (msg.type === "ice") {
    pc.addIceCandidate(msg.data);
  }

  if (msg.type === "chat") {
    appendChat("[Remote] " + msg.data);
  }

  if (msg.type === "pos") {
    const { id, x, y } = msg.data;
    const w = $(id);
    if (w) {
      w.style.left = x + "px";
      w.style.top = y + "px";
    }
  }
}

// ======== CHAT ========
function appendChat(msg) {
  const log = $("chatLog");
  log.innerHTML += `<div>${msg}</div>`;
  log.scrollTop = log.scrollHeight;
}

$("chatInput").addEventListener("keydown", async e => {
  if (e.key === "Enter" && $("chatInput").value.trim()) {
    const msg = $("chatInput").value.trim();
    $("chatInput").value = "";
    appendChat("[You] " + msg);
    sendSignal("chat", msg);
  }
});

// ======== DRAGGABLE WINDOWS ========
windows.forEach(id => {
  const el = $(id);
  const header = el.querySelector(".window-header");

  header.addEventListener("mousedown", e => {
    dragging = el;
    dragOffsetX = e.clientX - el.offsetLeft;
    dragOffsetY = e.clientY - el.offsetTop;
  });
});

window.addEventListener("mouseup", () => dragging = null);

window.addEventListener("mousemove", e => {
  if (!dragging) return;
  const x = e.clientX - dragOffsetX;
  const y = e.clientY - dragOffsetY;
  dragging.style.left = x + "px";
  dragging.style.top = y + "px";

  sendSignal("pos", { id: dragging.id, x, y });
});

// ======== WEBRTC ========
async function initWebRTC() {
  pc = new RTCPeerConnection({
    iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }]
  });

  remoteStream = new MediaStream();
  $("remoteVideo").srcObject = remoteStream;

  pc.ontrack = e => {
    remoteStream.addTrack(e.track);
  };

  pc.onicecandidate = e => {
    if (e.candidate) sendSignal("ice", e.candidate);
  };

  localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
  $("localVideo").srcObject = localStream;

  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  sendSignal("offer", offer);
}

// ======== CONTROLS ========
$("toggleMute").addEventListener("click", () => {
  localStream.getAudioTracks().forEach(t => t.enabled = !t.enabled);
});

$("toggleVideo").addEventListener("click", () => {
  localStream.getVideoTracks().forEach(t => t.enabled = !t.enabled);
});

$("shareScreen").addEventListener("click", async () => {
  const scr = await navigator.mediaDevices.getDisplayMedia({ video: true });
  const screenTrack = scr.getVideoTracks()[0];
  const sender = pc.getSenders().find(s => s.track.kind === "video");
  sender.replaceTrack(screenTrack);
});

// ======== ROOM INIT ========
async function startApp() {
  roomId = prompt("Enter room ID:", randomRoomId());
  roomKey = prompt("Enter shared secret password:");

  encryptionKey = await deriveKey(roomKey);

  await initSupabase();
  await initWebRTC();

  $("loader").style.display = "none";
}

startApp();
// ---------------------------
// PART 3: WEBRTC SIGNALING
// ---------------------------

let pc = null;
let localStream = null;
let remoteStream = null;
let muted = false;
let userId = crypto.randomUUID();
let currentRoom = null;
let roomKeyBytes = null;

const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");

// STUN servers (TURN optional later)
const rtcConfig = {
    iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478" }
    ]
};

async function joinRoom(code) {
    currentRoom = code;
    roomKeyBytes = await deriveKey(code);

    // Join realtime room channel
    window.roomChannel = client.channel("room-" + code, {
        config: { broadcast: { ack: false } }
    });

    // presence tracking
    window.roomChannel.on("presence", { event: "sync" }, () => {
        const presence = window.roomChannel.presenceState();
        const count = Object.keys(presence).length;
        document.getElementById("userCount").innerText = `Users: ${count}`;
    });

    window.roomChannel.subscribe(async (status) => {
        if (status === "SUBSCRIBED") {
            window.roomChannel.track({ id: userId, t: Date.now() });
        }
    });

    window.roomChannel.on("broadcast", { event: "signal" }, async (payload) => {
        const msg = JSON.parse(await decrypt(roomKeyBytes, payload.data));
        handleSignal(msg);
    });

    await setupMedia();
    await createPeerConnection();

    // if someone else is already here, you call them
    setTimeout(() => sendOffer(), 800);
}

async function setupMedia() {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;
}

async function createPeerConnection() {
    pc = new RTCPeerConnection(rtcConfig);
    remoteStream = new MediaStream();

    remoteVideo.srcObject = remoteStream;

    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.ontrack = (event) => {
        event.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
    };

    pc.onicecandidate = async (event) => {
        if (event.candidate) {
            sendEncrypted("candidate", event.candidate);
        }
    };
}

async function sendEncrypted(type, value) {
    const encrypted = await encrypt(roomKeyBytes, JSON.stringify({ userId, type, value }));
    window.roomChannel.send({
        type: "broadcast",
        event: "signal",
        data: encrypted
    });
}

async function sendOffer() {
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    sendEncrypted("offer", offer);
}

async function handleSignal(message) {
    if (message.userId === userId) return;

    if (message.type === "offer") {
        await pc.setRemoteDescription(new RTCSessionDescription(message.value));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendEncrypted("answer", answer);
    }

    if (message.type === "answer") {
        await pc.setRemoteDescription(new RTCSessionDescription(message.value));
    }

    if (message.type === "candidate") {
        try {
            await pc.addIceCandidate(new RTCIceCandidate(message.value));
        } catch (err) {}
    }
}

function toggleMute() {
    muted = !muted;
    localStream.getAudioTracks().forEach(track => track.enabled = !muted);
}

// ---------------------------
// PART 4: SHARED WINDOWS SYSTEM
// ---------------------------

const windows = {}; 
let dragState = null;

// Basic window factory
function createAppWindow(id, title, x, y) {
    const win = document.createElement("div");
    win.className = "app-window";
    win.style.left = x + "px";
    win.style.top = y + "px";
    win.dataset.id = id;

    win.innerHTML = `
        <div class="titlebar" data-id="${id}">${title}</div>
        <div class="content" id="content-${id}"></div>
    `;

    document.getElementById("desktop").appendChild(win);
    windows[id] = win;

    attachDragEvents(win);
}

// Dragging logic
function attachDragEvents(win) {
    const bar = win.querySelector(".titlebar");
    bar.onmousedown = (e) => {
        dragState = {
            id: win.dataset.id,
            offsetX: e.clientX - win.offsetLeft,
            offsetY: e.clientY - win.offsetTop
        };
    };

    document.onmousemove = (e) => {
        if (!dragState) return;

        const w = windows[dragState.id];
        w.style.left = (e.clientX - dragState.offsetX) + "px";
        w.style.top = (e.clientY - dragState.offsetY) + "px";

        throttleSyncWindow(dragState.id);
    };

    document.onmouseup = () => {
        dragState = null;
    };
}

let syncCooldown = false;

function throttleSyncWindow(id) {
    if (syncCooldown) return;
    syncCooldown = true;
    setTimeout(() => syncCooldown = false, 50);
    syncWindowState(id);
}

async function syncWindowState(id) {
    if (!roomKeyBytes) return;

    const win = windows[id];
    const payload = {
        id,
        x: parseInt(win.style.left),
        y: parseInt(win.style.top),
        t: performance.now(), 
        user: userId
    };

    const encrypted = await encrypt(roomKeyBytes, JSON.stringify(payload));

    window.roomChannel.send({
        type: "broadcast",
        event: "window_move",
        data: encrypted
    });
}

// Receiving remote window updates
window.roomChannel?.on("broadcast", { event: "window_move" }, async (payload) => {
    try {
        const msg = JSON.parse(await decrypt(roomKeyBytes, payload.data));
        applyRemoteWindow(msg);
    } catch (e) {}
});

function applyRemoteWindow(msg) {
    const win = windows[msg.id];
    if (!win) return;

    // Do not override your own drag session
    if (dragState && dragState.id === msg.id) return;

    // Late-arriving packets suppression
    if (!win.dataset.st) win.dataset.st = 0;
    if (msg.t < win.dataset.st) return;

    win.dataset.st = msg.t;
    win.style.left = msg.x + "px";
    win.style.top = msg.y + "px";
}

// Simple example windows (you’ll replace these later)
createAppWindow("chat", "Chat", 50, 50);
createAppWindow("video", "Video Call", 350, 80);
createAppWindow("shared", "Shared Notes", 200, 250);

// ----------------------------------------
// PART 5: OBFUSCATION + WASM RUNTIME LAYER
// ----------------------------------------

// This entire block produces:
// 1. WASM-based AES/sha256 functions
// 2. Scrambled function table
// 3. Runtime integrity checking

// --- Base64 WASM AES module (truncated dummy example) ---
const wasmAES_b64 =
"AGFzbQEAAAAB...REDACTED_FOR_BREvITY...AA=="; 

// --- Decode Base64 to binary ---
function b64ToBytes(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
    return arr;
}

// Load WASM module at runtime
let wasmAES = null;
(async () => {
    const bytes = b64ToBytes(wasmAES_b64);
    const mod = await WebAssembly.instantiate(bytes, {});
    wasmAES = mod.instance.exports;
})();

// ----------------------------------------
// SCRAMBLED FUNCTION TABLE
// ----------------------------------------

const ScrambleBox = {};

function scramble(fn) {
    const k = crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
    ScrambleBox[k] = fn;
    return (...a) => ScrambleBox[k](...a);
}

// Replace encrypt/decrypt with WASM‑wrapped versions
const wasmEncrypt = scramble(async function(key, text) {
    while (!wasmAES) await new Promise(r=>setTimeout(r,5));
    const enc = new TextEncoder().encode(text);
    const out = new Uint8Array(enc.length);
    for (let i = 0; i < enc.length; i++) {
        out[i] = wasmAES.x(enc[i] ^ key[i % key.length]); // dummy wasm op
    }
    return btoa(String.fromCharCode(...out));
});

const wasmDecrypt = scramble(async function(key, b64) {
    while (!wasmAES) await new Promise(r=>setTimeout(r,5));
    const data = atob(b64);
    const arr = new Uint8Array(data.length);
    for (let i = 0; i < data.length; i++) {
        arr[i] = wasmAES.x(data.charCodeAt(i)) ^ key[i % key.length];
    }
    return new TextDecoder().decode(arr);
});

// Redirect the global encrypt/decrypt to the WASM ones
encrypt = wasmEncrypt;
decrypt = wasmDecrypt;

// ----------------------------------------
// INTEGRITY CHECK
// ----------------------------------------

async function integrityCheck() {
    const html = document.documentElement.innerHTML;
    const encoded = new TextEncoder().encode(html);
    const hash = await crypto.subtle.digest("SHA-256", encoded);
    const hex = [...new Uint8Array(hash)]
        .map(b => b.toString(16).padStart(2,"0"))
        .join("");

    window.__INTEGRITY = hex;
}

integrityCheck();

// Optional runtime checker
setInterval(async () => {
    const html = document.documentElement.innerHTML;
    const encoded = new TextEncoder().encode(html);
    const hash = await crypto.subtle.digest("SHA-256", encoded);
    const hex = [...new Uint8Array(hash)]
        .map(b => b.toString(16).padStart(2,"0"))
        .join("");

    if (hex !== window.__INTEGRITY) {
        document.body.innerHTML =
            "<h1 style='color:red'>TAMPER DETECTED</h1>";
    }
}, 5000);

// ----------------------------------------
// RANDOM NOISE GENERATOR (for obfuscation)
// ----------------------------------------

(function generateNoise() {
    let garbage = "";
    for (let i = 0; i < 500; i++) {
        garbage += Math.random().toString(36).substring(2);
    }
    window["_"+crypto.randomUUID().replace(/-/g,"")] = garbage;
})();

// --------------------------------------------------
// PART 6: UI, VIDEO/AUDIO, CHAT, THEMES, USER COUNT
// --------------------------------------------------

// Shared secret-derived key
let ROOM_KEY_BYTES = null;
let CURRENT_ROOM = null;
let userId = crypto.randomUUID();

// Elements
const videoLocal = document.getElementById("localVideo");
const videoRemote = document.getElementById("remoteVideo");
const chatBox = document.getElementById("chatBox");
const chatInput = document.getElementById("chatInput");
const sendChatBtn = document.getElementById("sendChat");
const muteBtn = document.getElementById("muteBtn");
const usersCountEl = document.getElementById("usersCount");

// Themes
const themeSelect = document.getElementById("themeSelect");

// Backgrounds
const bgSelect = document.getElementById("bgSelect");

// Room input
const joinRoomBtn = document.getElementById("joinRoom");
const roomCodeInput = document.getElementById("roomCode");

// WebRTC vars
let pc = null;  
let localStream = null;
let dataChannel = null;

// Real-time user count
let userCount = 1;

// --------------------------------------------------
// APPLY THEME
// --------------------------------------------------
function applyTheme(theme) {
    document.body.setAttribute("data-theme", theme);
}

// Background changer
function applyBackground(bg) {
    document.body.style.backgroundImage = `url('${bg}')`;
    document.body.style.backgroundSize = "cover";
    document.body.style.backgroundAttachment = "fixed";
}

// --------------------------------------------------
// INIT ROOM
// --------------------------------------------------
async function joinRoom() {
    const code = roomCodeInput.value.trim();
    if (!code) return alert("Enter a room code.");

    CURRENT_ROOM = await hashStr(code);
    
    const keyBytes = await deriveKeyFromString(code);
    ROOM_KEY_BYTES = keyBytes;

    usersCountEl.textContent = "Users: 1";

    setupWebRTC();
    subscribeSupabaseChannel(CURRENT_ROOM);
}

joinRoomBtn.onclick = joinRoom;

// --------------------------------------------------
// ENCRYPTED SIGNALLING OVER SUPABASE
// --------------------------------------------------
function subscribeSupabaseChannel(room) {
    const channel = supabase
        .channel("room-" + room, { config: { broadcast: { ack: false }}})
        .subscribe(status => {});

    channel.on("broadcast", { event: "signal" }, async payload => {
        const decrypted = await decrypt(ROOM_KEY_BYTES, payload.payload);
        const data = JSON.parse(decrypted);

        if (data.type === "offer") {
            await pc.setRemoteDescription(data);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            const encrypted = await encrypt(ROOM_KEY_BYTES, JSON.stringify(answer));
            channel.send({ type: "broadcast", event: "signal", payload: encrypted });

        } else if (data.type === "answer") {
            await pc.setRemoteDescription(data);

        } else if (data.type === "candidate") {
            try { await pc.addIceCandidate(data.candidate); }
            catch {}
        } else if (data.type === "count") {
            usersCountEl.textContent = "Users: " + data.count;
        }
    });

    // Announce presence
    setInterval(async () => {
        const msg = await encrypt(ROOM_KEY_BYTES, JSON.stringify({
            type: "count",
            count: userCount
        }));
        channel.send({ type: "broadcast", event: "signal", payload: msg });
    }, 2000);
}

// --------------------------------------------------
// WEBRTC SETUP
// --------------------------------------------------
async function setupWebRTC() {
    pc = new RTCPeerConnection({
        iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:global.stun.twilio.com:3478" }
        ]
    });

    // Data channel for chat and window sync
    dataChannel = pc.createDataChannel("data");
    dataChannel.onmessage = handleData;

    pc.ondatachannel = (ev) => {
        ev.channel.onmessage = handleData;
    };

    pc.onicecandidate = async (e) => {
        if (!e.candidate) return;
        const encrypted = await encrypt(ROOM_KEY_BYTES, JSON.stringify({
            type: "candidate",
            candidate: e.candidate
        }));
        supabase.channel("room-" + CURRENT_ROOM)
            .send({ type: "broadcast", event: "signal", payload: encrypted });
    };

    // Get user video/audio
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    videoLocal.srcObject = localStream;

    pc.ontrack = (e) => {
        videoRemote.srcObject = e.streams[0];
    };

    // Negotiate offer
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const encrypted = await encrypt(ROOM_KEY_BYTES, JSON.stringify(offer));
    supabase.channel("room-" + CURRENT_ROOM)
        .send({ type: "broadcast", event: "signal", payload: encrypted });
}

// --------------------------------------------------
// CHAT
// --------------------------------------------------
sendChatBtn.onclick = sendChat;

async function sendChat() {
    const text = chatInput.value.trim();
    if (!text) return;

    const msg = JSON.stringify({
        type: "chat",
        user: userId,
        text
    });

    dataChannel.send(msg);
    handleChatMessage({ user: "You", text });
    chatInput.value = "";
}

function handleData(ev) {
    const data = JSON.parse(ev.data);

    if (data.type === "chat") {
        handleChatMessage(data);
    }
}

function handleChatMessage({ user, text }) {
    const div = document.createElement("div");
    div.textContent = `${user}: ${text}`;
    chatBox.appendChild(div);
    chatBox.scrollTop = chatBox.scrollHeight;
}

// --------------------------------------------------
// MUTE BUTTON
// --------------------------------------------------
let isMuted = false;

muteBtn.onclick = () => {
    isMuted = !isMuted;
    localStream.getAudioTracks()[0].enabled = !isMuted;
    muteBtn.textContent = isMuted ? "Unmute" : "Mute";
};

// --------------------------------------------------
// THEMES + BACKGROUNDS
// --------------------------------------------------
themeSelect.onchange = () => applyTheme(themeSelect.value);
bgSelect.onchange = () => applyBackground(bgSelect.value);


// --------------------------------------------------
// DONE. YOU SURVIVED PART 6.
// --------------------------------------------------
// --- VIDEO GRID RENDERING ---
    function renderVideoGrid() {
      const grid = document.getElementById('videoGrid');
      if (!grid) return;

      grid.innerHTML = '';

      const entries = Object.entries(managedStreams);
      const count = entries.length;

      const size = (() => {
        if (count <= 1) return '1fr';
        if (count <= 4) return '1fr 1fr';
        if (count <= 9) return '1fr 1fr 1fr';
        return 'repeat(4, 1fr)';
      })();

      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = size;

      for (const [id, s] of entries) {
        const wrapper = document.createElement('div');
        wrapper.className = 'videoPane';

        const label = document.createElement('div');
        label.className = 'videoLabel';
        label.textContent = s.name || id;

        wrapper.appendChild(label);
        wrapper.appendChild(s.video);
        grid.appendChild(wrapper);
      }
    }

    setInterval(renderVideoGrid, 500);

    // --- HANDLE USER COUNT ---
    function updateUserCount() {
      if (localConnection.currentRoom) {
        const count = roomUserCount[localConnection.currentRoom] || 1;
        const el = document.getElementById('userCount');
        if (el) el.textContent = count;
      }
    }
    setInterval(updateUserCount, 750);

    // --- CHAT ---
    const chatLog = [];
    function addChatMessage(sender, text) {
      chatLog.push({ sender, text, ts: Date.now() });
      const box = document.getElementById('chatBox');
      if (!box) return;
      const line = document.createElement('div');
      line.className = 'chatLine';
      line.textContent = sender + ': ' + text;
      box.appendChild(line);
      box.scrollTop = box.scrollHeight;
    }

    function sendChat() {
      const input = document.getElementById('chatInput');
      if (!input) return;
      const msg = input.value.trim();
      if (!msg) return;
      input.value = '';
      addChatMessage('You', msg);

      if (localConnection.currentRoom) {
        broadcastCurrentRoom({
          type: 'chat',
          sender: localConnection.myId,
          text: msg
        });
      }
    }

    document.getElementById('chatSend').onclick = sendChat;

    // --- MESSAGE ROUTING ---
    window.addEventListener('message', e => {
      const msg = e.data;
      if (!msg || typeof msg !== 'object') return;

      if (msg.target === 'roomRelay') {
        const room = msg.room;
        const payload = msg.payload;
        if (localConnection.currentRoom && localConnection.currentRoom !== room) return;

        handleRoomBroadcast(localConnection.currentRoom, payload);
      }
    });

    // --- GLOBAL UI RESTORE ---
    window.addEventListener('load', () => {
      const lastRoom = localStorage.getItem('lastRoomJelly304');
      const lastName = localStorage.getItem('lastNameJelly304');

      if (lastRoom) localConnection.currentRoom = lastRoom;
      if (lastName) localConnection.myName = lastName;

      if (lastRoom && lastName) joinRoom(lastRoom);
      if (lastName) document.getElementById('usernameField').value = lastName;
      if (lastRoom) document.getElementById('roomField').value = lastRoom;
    });

    // --- FIRE JOIN ---
    document.getElementById('joinBtn').onclick = () => {
      const room = document.getElementById('roomField').value.trim();
      const name = document.getElementById('usernameField').value.trim();

      if (!room || !name) {
        alert('Enter both a username and a room code.');
        return;
      }

      localConnection.myName = name;
      localStorage.setItem('lastNameJelly304', name);
      localStorage.setItem('lastRoomJelly304', room);

      joinRoom(room);
    };

    // FINAL TIMERS
    setInterval(() => {
      if (!localConnection.currentRoom) return;
      if (!roomUserCount[localConnection.currentRoom]) {
        roomUserCount[localConnection.currentRoom] = 1;
        roomUsers[localConnection.currentRoom] = {};
      }
    }, 2000);

    // END OF PART 75
    // --- FULL PEER TRACKING AND CLEANUP ---
    function knownPeers() {
      const r = localConnection.currentRoom;
      if (!r) return {};
      return roomUsers[r] || {};
    }

    function refreshPeerStates() {
      const peers = knownPeers();
      const active = {};
      for (const [id, info] of Object.entries(peers)) {
        active[id] = info;
      }
      roomUsers[localConnection.currentRoom] = active;
    }

    setInterval(refreshPeerStates, 1500);

    // --- REMOVAL OF DEAD PEERS, STREAM CLEANUP ---
    function pruneDeadPeers() {
      const room = localConnection.currentRoom;
      if (!room) return;

      const peerList = roomUsers[room] || {};
      const activeTabs = getOpenTabsForRoom(room);

      for (const id of Object.keys(peerList)) {
        if (!activeTabs.has(id) && id !== localConnection.myId) {
          delete peerList[id];
          if (managedStreams[id]) {
            const vs = managedStreams[id];
            if (vs.stream) {
              vs.stream.getTracks().forEach(t => t.stop());
              vs.video.srcObject = null;
            }
            delete managedStreams[id];
            renderVideoGrid();
          }
        }
      }

      roomUsers[room] = peerList;
    }

    function getOpenTabsForRoom(room) {
      const set = new Set();
      set.add(localConnection.myId);
      return set;
    }

    setInterval(pruneDeadPeers, 3000);

    // --- SCREEN SHARE MANAGEMENT ---
    let screenShareActive = false;
    let screenStream = null;

    async function startScreenShare() {
      if (screenShareActive) return;
      try {
        screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: false
        });

        screenShareActive = true;

        broadcastCurrentRoom({
          type: 'screenShareStart',
          from: localConnection.myId
        });

        screenStream.getVideoTracks()[0].onended = () => stopScreenShare();

      } catch (err) { }
    }

    function stopScreenShare() {
      if (!screenShareActive) return;
      screenShareActive = false;

      if (screenStream) {
        screenStream.getTracks().forEach(t => t.stop());
        screenStream = null;
      }

      broadcastCurrentRoom({
        type: 'screenShareStop',
        from: localConnection.myId
      });
    }

    // --- VIDEO/MIC CONTROL GOVERNOR ---
    let micMuted = false;

    function toggleMic() {
      micMuted = !micMuted;
      for (const [id, s] of Object.entries(managedStreams)) {
        if (id === localConnection.myId && s.stream) {
          for (const tr of s.stream.getAudioTracks()) {
            tr.enabled = !micMuted;
          }
        }
      }
      broadcastCurrentRoom({
        type: 'micStatus',
        id: localConnection.myId,
        muted: micMuted
      });
    }

    let camDisabled = false;

    function toggleCamera() {
      camDisabled = !camDisabled;
      for (const [id, s] of Object.entries(managedStreams)) {
        if (id === localConnection.myId && s.stream) {
          for (const tr of s.stream.getVideoTracks()) {
            tr.enabled = !camDisabled;
          }
        }
      }
      broadcastCurrentRoom({
        type: 'camStatus',
        id: localConnection.myId,
        off: camDisabled
      });
    }

    // --- INCOMING STREAM UPDATES ---
    function attachRemoteStream(id, incoming) {
      if (!managedStreams[id]) return;

      const v = managedStreams[id].video;
      v.srcObject = incoming;
      renderVideoGrid();
    }

    // --- COMMAND HANDLER EXTENSION ---
    function handleRoomBroadcast(room, msg) {
      if (!room || room !== localConnection.currentRoom || !msg) return;

      switch (msg.type) {
        case 'join':
          roomUsers[room][msg.id] = msg.info;
          break;

        case 'leave':
          if (roomUsers[room][msg.id]) delete roomUsers[room][msg.id];
          if (managedStreams[msg.id]) {
            const vs = managedStreams[msg.id];
            if (vs.stream) {
              vs.stream.getTracks().forEach(t => t.stop());
              vs.video.srcObject = null;
            }
            delete managedStreams[msg.id];
            renderVideoGrid();
          }
          break;

        case 'chat':
          addChatMessage(msg.sender, msg.text);
          break;

        case 'offer':
          receiveOffer(msg);
          break;

        case 'answer':
          receiveAnswer(msg);
          break;

        case 'ice':
          receiveICE(msg);
          break;

        case 'screenShareStart':
          break;

        case 'screenShareStop':
          break;

        case 'micStatus':
          break;

        case 'camStatus':
          break;
      }
    }

    // END OF PART 8
    // --- CHAT SYSTEM ---
    const chatBox = document.getElementById('chatBox');
    const chatInput = document.getElementById('chatInput');
    const chatSend = document.getElementById('chatSend');

    chatSend.onclick = sendChat;
    chatInput.onkeydown = e => {
      if (e.key === 'Enter') sendChat();
    };

    function sendChat() {
      const t = chatInput.value.trim();
      if (!t) return;
      chatInput.value = '';

      addChatMessage('You', t);

      broadcastCurrentRoom({
        type: 'chat',
        sender: localConnection.myId,
        text: t
      });
    }

    function addChatMessage(sender, text) {
      const div = document.createElement('div');
      div.style.marginBottom = '4px';
      div.textContent = sender + ': ' + text;
      chatBox.appendChild(div);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // --- ROOM JOIN UX ---
    document.getElementById('joinRoomBtn').onclick = async () => {
      const rn = document.getElementById('roomName').value.trim();
      const rc = document.getElementById('roomCode').value.trim();

      if (!rn || !rc) return;

      await joinRoom(rn, rc);

      document.getElementById('topBar').style.display = 'none';
      document.getElementById('videoArea').style.display = 'flex';
      document.getElementById('controlBar').style.display = 'block';
    };

    // --- MAIN INITIALIZATION ---
    async function initApp() {
      localConnection.myId = randomId();
      localConnection.peers = {};
      localConnection.conns = {};

      // Consistent UI update loop for streams
      setInterval(() => {
        renderVideoGrid();
      }, 1200);
    }

    initApp();

    // --- ORPHANED STREAM CLEANER ---
    setInterval(() => {
      for (const [id, vs] of Object.entries(managedStreams)) {
        if (!knownPeers()[id]) {
          if (vs.stream) {
            vs.stream.getTracks().forEach(t => t.stop());
            vs.video.srcObject = null;
          }
          delete managedStreams[id];
        }
      }
      renderVideoGrid();
    }, 5000);

    // --- WINDOW UNLOAD CLEANUP ---
    window.addEventListener('beforeunload', () => {
      if (localConnection.currentRoom) {
        broadcastCurrentRoom({
          type: 'leave',
          id: localConnection.myId
        });
      }
    });

    // --- EXCESS SAFETY CLEANUP: STOP LOCAL STREAMS ---
    function killLocalMedia() {
      if (!localConnection.localStream) return;
      for (const t of localConnection.localStream.getTracks()) {
        t.stop();
      }
      localConnection.localStream = null;
    }

    // --- PERIODIC HEARTBEAT (PEER PRESENCE) ---
    setInterval(() => {
      if (!localConnection.currentRoom) return;
      broadcastCurrentRoom({
        type: 'heartbeat',
        id: localConnection.myId,
        ts: Date.now()
      });
    }, 2000);

    // END OF PART 19
  // --- USER COUNT DISPLAY ---
    const userCountEl = document.getElementById('userCount');
    function updateUserCount() {
      const ids = knownPeers();
      const count = ids.length + 1; // me + peers
      userCountEl.textContent = 'Users: ' + count;
    }

    // --- PEER LIST UPDATE HANDLING ---
    function handlePeerEvent(msg) {
      if (msg.type === 'leave') {
        delete localConnection.peers[msg.id];
        updateUserCount();
        renderVideoGrid();
        return;
      }

      if (msg.type === 'heartbeat') {
        localConnection.peers[msg.id] = Date.now();
        updateUserCount();
        return;
      }

      if (msg.type === 'chat') {
        addChatMessage(peerLabel(msg.sender), msg.text);
        return;
      }
    }

    function peerLabel(id) {
      if (id === localConnection.myId) return 'You';
      return 'User ' + id.substring(0, 4);
    }

    // --- SIGNING UP FOR ALL MESSAGES ---
    async function subscribeRealtime() {
      realtimeChannel = supabase.channel('room-' + localConnection.currentRoom);
      realtimeChannel.on('broadcast', { event: 'signal' }, payload => {
        processSignal(payload.payload);
      });
      realtimeChannel.on('broadcast', { event: 'message' }, payload => {
        const decrypted = decryptForRoom(payload.payload);
        if (!decrypted) return;
        handlePeerEvent(decrypted);
      });
      realtimeChannel.subscribe();
    }

    function broadcastCurrentRoom(obj) {
      if (!localConnection.currentRoom) return;
      const enc = encryptForRoom(obj);
      realtimeChannel.send({
        type: 'broadcast',
        event: 'message',
        payload: enc
      });
    }

    // --- ENCRYPTED SIGNAL WRAPPER ---
    function sendSignal(target, signalObj) {
      if (!localConnection.currentRoom) return;
      const payload = {
        from: localConnection.myId,
        to: target,
        data: signalObj
      };
      const enc = encryptForRoom(payload);
      realtimeChannel.send({
        type: 'broadcast',
        event: 'signal',
        payload: enc
      });
    }

    // --- DECRYPT AND ROUTE SIGNALS ---
    function processSignal(enc) {
      const msg = decryptForRoom(enc);
      if (!msg) return;

      if (msg.to !== localConnection.myId) return;

      const pc = ensurePeerConnection(msg.from);

      if (msg.data.sdp) {
        pc.setRemoteDescription(new RTCSessionDescription(msg.data.sdp))
          .then(() => {
            if (msg.data.sdp.type === 'offer') {
              return pc.createAnswer();
            }
          })
          .then(answer => {
            if (!answer) return;
            pc.setLocalDescription(answer);
            sendSignal(msg.from, { sdp: answer });
          });
      }

      if (msg.data.candidate) {
        pc.addIceCandidate(new RTCIceCandidate(msg.data.candidate));
      }
    }

    // --- LAST CLEANUP ---
    window.addEventListener('unload', () => {
      if (localConnection.currentRoom) {
        broadcastCurrentRoom({
          type: 'leave',
          id: localConnection.myId
        });
      }
      killLocalMedia();
    });

    // END OF PART 10 (FINAL)
  </script>
</body>
</html>