<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ciphernexus | Auto-Join Rooms</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    
    <!-- PeerJS (WebRTC Signaling) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- QR Tools -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        nexus: {
                            dark: '#050510',
                            panel: 'rgba(20, 20, 35, 0.7)',
                            neon: '#00f3ff',
                            purple: '#bc13fe',
                            success: '#00ff9d',
                            danger: '#ff0055'
                        }
                    },
                    fontFamily: {
                        mono: ['Courier New', 'monospace'],
                        sans: ['Segoe UI', 'Roboto', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background-color: #020205;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(188, 19, 254, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(0, 243, 255, 0.1) 0%, transparent 20%);
            color: #e0e0e0;
            overflow: hidden; 
        }

        .glass-panel {
            background: rgba(20, 20, 35, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .neon-border {
            box-shadow: 0 0 5px rgba(0, 243, 255, 0.2), inset 0 0 5px rgba(0, 243, 255, 0.1);
            border: 1px solid rgba(0, 243, 255, 0.3);
        }
        
        .neon-text {
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
        }

        .btn-primary {
            background: linear-gradient(90deg, #00f3ff 0%, #bc13fe 100%);
            color: #000;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn-primary:hover {
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
            transform: translateY(-1px);
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(0, 243, 255, 0.3); border-radius: 3px; }

        @keyframes scanline {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .scan-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(to bottom, transparent, rgba(0, 243, 255, 0.1), transparent);
            animation: scanline 4s linear infinite;
            pointer-events: none;
            z-index: 50;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
        }
        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>
<body class="h-screen w-screen text-sm">

    <!-- APP CONTAINER -->
    <div id="app" class="relative h-full w-full flex flex-col items-center justify-center">

        <!-- LOGIN SCREEN -->
        <div id="login-screen" class="absolute z-50 w-full h-full flex items-center justify-center bg-nexus-dark">
            <div class="scan-overlay"></div>
            <div class="glass-panel p-8 rounded-2xl w-96 max-w-[90%] flex flex-col gap-6 relative z-10">
                <div class="text-center">
                    <h1 class="text-3xl font-bold font-mono text-white tracking-wider neon-text">CIPHERNEXUS</h1>
                    <p class="text-xs text-nexus-neon mt-2 opacity-80">E2E ENCRYPTED // AUTO-ROOMS</p>
                </div>
                
                <div class="space-y-4">
                    <div>
                        <label class="text-xs text-gray-400 font-mono">AGENT ID (NICKNAME)</label>
                        <input type="text" id="nickname-input" class="w-full bg-black/50 border border-gray-700 rounded p-3 text-white focus:border-nexus-neon outline-none transition" placeholder="Enter alias...">
                    </div>
                    <div>
                        <label class="text-xs text-gray-400 font-mono">ROOM PASSWORD</label>
                        <input type="password" id="password-input" class="w-full bg-black/50 border border-gray-700 rounded p-3 text-white focus:border-nexus-purple outline-none transition" placeholder="Users with same pass will connect">
                    </div>
                </div>

                <div class="space-y-3">
                    <button onclick="Nexus.initSession()" class="btn-primary w-full p-3 rounded shadow-lg">
                        <i class="fas fa-satellite-dish mr-2"></i> Join Room
                    </button>
                    <div id="status-msg" class="text-center text-xs text-nexus-neon h-4"></div>
                </div>
            </div>
        </div>

        <!-- MAIN INTERFACE (Hidden initially) -->
        <div id="main-ui" class="hidden w-full h-full flex flex-col md:flex-row overflow-hidden relative">
            
            <!-- LEFT SIDEBAR -->
            <div class="w-full md:w-64 glass-panel flex flex-col border-r border-gray-800 z-20">
                <div class="p-4 border-b border-gray-800 flex justify-between items-center">
                    <h2 class="font-mono font-bold text-nexus-neon">NEXUS LINK</h2>
                    <div id="connection-status" class="w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_red]"></div>
                </div>
                
                <!-- User List -->
                <div class="flex-1 overflow-y-auto p-4 space-y-3" id="user-list">
                    <div class="text-xs text-gray-500 italic">Waiting for peers in room...</div>
                </div>

                <!-- Session Info -->
                <div class="p-4 bg-black/20 border-t border-gray-800 text-xs font-mono space-y-2">
                    <div class="flex justify-between">
                        <span class="text-gray-400">ROLE:</span>
                        <span id="my-role-display" class="text-nexus-purple font-bold">...</span>
                    </div>
                     <div class="flex justify-between">
                        <span class="text-gray-400">ID:</span>
                        <span id="my-peer-id-display" class="text-white truncate w-16" title="Click to copy">...</span>
                    </div>
                </div>
            </div>

            <!-- CENTER: CHAT & VIDEO -->
            <div class="flex-1 flex flex-col bg-nexus-dark/80 relative">
                
                <!-- Video Grid -->
                <div id="video-grid" class="hidden flex-wrap gap-2 p-2 bg-black/40 min-h-[200px] border-b border-gray-800">
                    <div id="local-video-container" class="video-container w-48 border border-nexus-neon">
                        <video id="local-video" muted autoplay playsinline></video>
                        <div class="absolute bottom-1 left-1 text-xs bg-black/70 px-1 text-nexus-neon">YOU</div>
                    </div>
                </div>

                <!-- Chat Area -->
                <div id="chat-box" class="flex-1 overflow-y-auto p-4 space-y-4 scroll-smooth">
                    <div class="flex justify-center my-4">
                        <span class="text-xs text-nexus-success bg-nexus-success/10 px-3 py-1 rounded-full border border-nexus-success/30">
                            <i class="fas fa-shield-alt mr-1"></i> Room Encrypted (AES-GCM)
                        </span>
                    </div>
                </div>

                <!-- Input Area -->
                <div class="p-4 glass-panel border-t border-gray-800">
                    <div id="file-progress-container" class="hidden mb-2">
                         <div class="flex justify-between text-xs text-nexus-neon mb-1">
                             <span id="file-status-text">Uploading...</span>
                             <span id="file-percent">0%</span>
                         </div>
                         <div class="w-full bg-gray-800 h-1 rounded overflow-hidden">
                             <div id="file-bar" class="bg-nexus-neon h-full w-0 transition-all duration-300"></div>
                         </div>
                    </div>

                    <form onsubmit="Nexus.sendMessage(event)" class="flex gap-3">
                        <label class="cursor-pointer text-gray-400 hover:text-nexus-neon flex items-center">
                            <i class="fas fa-paperclip text-lg"></i>
                            <input type="file" id="file-input" class="hidden" onchange="Nexus.handleFileUpload(this)">
                        </label>
                        <input type="text" id="msg-input" class="flex-1 bg-black/50 border border-gray-700 rounded-full px-4 text-white focus:border-nexus-neon outline-none" placeholder="Encrypted message..." autocomplete="off">
                        <button type="submit" class="text-nexus-neon hover:text-white transition">
                            <i class="fas fa-paper-plane text-lg"></i>
                        </button>
                    </form>
                </div>

                <!-- Floating Video Controls -->
                <div class="absolute top-4 right-4 flex gap-2">
                    <button onclick="Nexus.toggleVideo()" id="btn-video" class="glass-panel w-10 h-10 rounded-full flex items-center justify-center text-gray-400 hover:text-white hover:border-nexus-neon transition">
                        <i class="fas fa-video"></i>
                    </button>
                    <button onclick="Nexus.toggleAudio()" id="btn-audio" class="glass-panel w-10 h-10 rounded-full flex items-center justify-center text-gray-400 hover:text-white hover:border-nexus-neon transition">
                        <i class="fas fa-microphone"></i>
                    </button>
                </div>
            </div>

        </div>

    </div>

    <!-- MAIN LOGIC -->
    <script>
        const Nexus = {
            state: {
                nick: '',
                password: '',
                roomIdHash: '',
                masterKey: null,
                peer: null,
                conn: null,
                call: null,
                localStream: null,
                files: {},
                isHost: false
            },

            // --- 1. CRYPTO & ID GENERATION ---

            async hashString(str) {
                const enc = new TextEncoder();
                const hashBuffer = await crypto.subtle.digest('SHA-256', enc.encode(str));
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            },

            async deriveKey(password) {
                const enc = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
                );
                return await window.crypto.subtle.deriveKey(
                    {
                        name: "PBKDF2",
                        salt: enc.encode("nexus_salt_v1"),
                        iterations: 100000,
                        hash: "SHA-256"
                    },
                    keyMaterial,
                    { name: "AES-GCM", length: 256 },
                    false,
                    ["encrypt", "decrypt"]
                );
            },

            async encrypt(data) {
                if (!this.state.masterKey) return null;
                const enc = new TextEncoder();
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encodedData = typeof data === 'string' ? enc.encode(data) : data;
                
                const ciphertext = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    this.state.masterKey,
                    encodedData
                );

                const buffer = new Uint8Array(iv.byteLength + ciphertext.byteLength);
                buffer.set(iv, 0);
                buffer.set(new Uint8Array(ciphertext), iv.byteLength);
                return buffer; 
            },

            async decrypt(buffer) {
                if (!this.state.masterKey) return null;
                try {
                    const iv = buffer.slice(0, 12);
                    const data = buffer.slice(12);
                    return await window.crypto.subtle.decrypt(
                        { name: "AES-GCM", iv: iv },
                        this.state.masterKey,
                        data
                    );
                } catch (e) {
                    console.error("Decryption failed", e);
                    return null;
                }
            },

            // --- 2. AUTO-JOIN LOGIC (THE FIX) ---

            async initSession() {
                const nick = document.getElementById('nickname-input').value;
                const pass = document.getElementById('password-input').value;
                const status = document.getElementById('status-msg');

                if (!nick || !pass) {
                    status.innerText = "Credentials required.";
                    return;
                }

                this.state.nick = nick;
                this.state.password = pass;
                status.innerText = "Deriving Keys & Hashing Room ID...";

                // 1. Generate Room ID from Password (deterministic)
                const hash = await this.hashString(pass);
                // PeerJS IDs must be alphanumeric. We use a prefix to avoid collisions with randoms.
                // We truncate to 16 chars for cleaner IDs, but enough entropy for this demo.
                this.state.roomIdHash = `nexus_room_${hash.substring(0, 16)}`;
                
                // 2. Derive Encryption Keys
                this.state.masterKey = await this.deriveKey(pass);

                // 3. Attempt to Claim the Room ID (Become Host)
                status.innerText = "Contacting Network...";
                
                const potentialHostPeer = new Peer(this.state.roomIdHash, { debug: 1 });

                potentialHostPeer.on('open', (id) => {
                    // SUCCESS: We are the Host!
                    this.finalizeLogin(potentialHostPeer, true);
                });

                potentialHostPeer.on('error', (err) => {
                    if (err.type === 'unavailable-id') {
                        // ID TAKEN: Someone is already host. We join them.
                        status.innerText = "Room found. Joining as Guest...";
                        const guestPeer = new Peer(); // Get random ID
                        
                        guestPeer.on('open', () => {
                            this.finalizeLogin(guestPeer, false);
                        });
                    } else {
                        status.innerText = "Network Error: " + err.type;
                    }
                });
            },

            finalizeLogin(peerInstance, isHost) {
                this.state.peer = peerInstance;
                this.state.isHost = isHost;

                // UI Transition
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('main-ui').classList.remove('hidden');
                
                document.getElementById('my-peer-id-display').innerText = this.state.peer.id;
                document.getElementById('my-role-display').innerText = isHost ? "HOST" : "GUEST";
                
                this.setupPeerEvents();

                if (!isHost) {
                    // Connect to the known Host ID
                    this.connectToPeer(this.state.roomIdHash);
                } else {
                    this.appendSystemMessage("Room Host Active. Waiting for peers...");
                }
                
                this.updateStatus(true);
            },

            setupPeerEvents() {
                this.state.peer.on('connection', (conn) => {
                    this.handleIncomingConnection(conn);
                });

                this.state.peer.on('call', (call) => {
                    this.handleIncomingCall(call);
                });
            },

            // --- 3. CONNECTION HANDLERS ---

            connectToPeer(targetId) {
                this.appendSystemMessage(`Connecting to Room Host...`);
                const conn = this.state.peer.connect(targetId);
                this.setupConnection(conn);
            },

            setupConnection(conn) {
                conn.on('open', async () => {
                    this.state.conn = conn;
                    this.appendSystemMessage(`Secure Channel Established.`);
                    this.updateStatus(true);
                    
                    // Send Handshake
                    const payload = JSON.stringify({ type: 'handshake', nick: this.state.nick });
                    const encrypted = await this.encrypt(payload);
                    conn.send(encrypted);
                });

                conn.on('data', async (data) => this.handleData(data));
                
                conn.on('close', () => {
                    this.appendSystemMessage("Connection lost.");
                    this.updateStatus(false);
                });
            },

            handleIncomingConnection(conn) {
                this.state.conn = conn;
                this.setupConnection(conn);
            },

            async handleData(arrayBuffer) {
                if (arrayBuffer instanceof Blob) arrayBuffer = await arrayBuffer.arrayBuffer();
                
                const decrypted = await this.decrypt(new Uint8Array(arrayBuffer));
                
                if (!decrypted) {
                    // If decryption fails, it means passwords didn't match
                    console.error("Decryption fail. Key mismatch.");
                    return;
                }

                const dec = new TextDecoder();
                const rawText = dec.decode(decrypted);
                const msgObj = JSON.parse(rawText);

                if (msgObj.type === 'chat') {
                    this.appendMessage(msgObj.nick, msgObj.text, false);
                } else if (msgObj.type === 'handshake') {
                    this.appendSystemMessage(`${msgObj.nick} joined the room.`);
                    this.addSidebarUser(msgObj.nick);
                } else if (msgObj.type === 'file-start') {
                    this.startFileReceive(msgObj);
                } else if (msgObj.type === 'file-chunk') {
                    this.receiveFileChunk(msgObj);
                }
            },

            // --- 4. MESSAGING & FILE UI ---

            async sendMessage(e) {
                e.preventDefault();
                const input = document.getElementById('msg-input');
                const text = input.value;
                if (!text || !this.state.conn) return;

                const payload = JSON.stringify({ type: 'chat', nick: this.state.nick, text: text });
                const encrypted = await this.encrypt(payload);
                
                this.state.conn.send(encrypted);
                this.appendMessage('ME', text, true);
                input.value = '';
            },

            appendMessage(nick, text, isMe) {
                const box = document.getElementById('chat-box');
                const div = document.createElement('div');
                div.className = `flex flex-col ${isMe ? 'items-end' : 'items-start'}`;
                
                const bubble = document.createElement('div');
                bubble.className = `max-w-[80%] p-3 rounded-lg ${isMe ? 'bg-nexus-purple text-white rounded-br-none' : 'bg-gray-800 border border-gray-700 text-gray-200 rounded-bl-none'}`;
                bubble.innerHTML = `<div class="text-[10px] opacity-70 mb-1 font-mono">${nick}</div><div>${this.escapeHtml(text)}</div>`;
                
                div.appendChild(div);
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            },

            appendSystemMessage(text) {
                const box = document.getElementById('chat-box');
                const div = document.createElement('div');
                div.className = 'text-center my-2';
                div.innerHTML = `<span class="text-xs text-nexus-neon font-mono bg-nexus-neon/10 px-2 py-1 rounded border border-nexus-neon/20">${text}</span>`;
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            },

            // --- 5. FILE TRANSFER ---

            async handleFileUpload(input) {
                const file = input.files[0];
                if (!file || !this.state.conn) return;

                const metaPayload = JSON.stringify({
                    type: 'file-start',
                    name: file.name,
                    size: file.size,
                    mime: file.type,
                    nick: this.state.nick
                });
                this.state.conn.send(await this.encrypt(metaPayload));

                this.appendSystemMessage(`Sending ${file.name}...`);
                document.getElementById('file-progress-container').classList.remove('hidden');

                const chunkSize = 16384; 
                let offset = 0;
                const reader = new FileReader();

                reader.onload = async (e) => {
                    const b64 = this.arrayBufferToBase64(e.target.result);
                    const chunkPayload = JSON.stringify({ type: 'file-chunk', data: b64 });
                    this.state.conn.send(await this.encrypt(chunkPayload));
                    
                    offset += e.target.result.byteLength;
                    this.updateProgressBar(offset, file.size);

                    if (offset < file.size) {
                        const slice = file.slice(offset, offset + chunkSize);
                        reader.readAsArrayBuffer(slice);
                    } else {
                        setTimeout(() => document.getElementById('file-progress-container').classList.add('hidden'), 2000);
                        this.appendSystemMessage(`Sent ${file.name}`);
                    }
                };
                reader.readAsArrayBuffer(file.slice(0, chunkSize));
            },

            startFileReceive(meta) {
                this.state.files['current'] = { meta: meta, received: 0, buffer: [] };
                this.appendSystemMessage(`Receiving ${meta.name}...`);
                document.getElementById('file-progress-container').classList.remove('hidden');
            },

            receiveFileChunk(chunkData) {
                const current = this.state.files['current'];
                if(!current) return;
                const bytes = this.base64ToArrayBuffer(chunkData.data);
                current.buffer.push(bytes);
                current.received += bytes.byteLength;
                this.updateProgressBar(current.received, current.meta.size);

                if (current.received >= current.meta.size) {
                    const blob = new Blob(current.buffer, { type: current.meta.mime });
                    const url = URL.createObjectURL(blob);
                    this.appendSystemMessage(`File Received: ${current.meta.name}`);
                    
                    const box = document.getElementById('chat-box');
                    const link = document.createElement('div');
                    link.className = 'text-center my-2';
                    link.innerHTML = `<a href="${url}" download="${current.meta.name}" class="text-nexus-neon underline font-bold bg-gray-800 p-2 rounded block">Download ${this.escapeHtml(current.meta.name)}</a>`;
                    box.appendChild(link);
                    
                    document.getElementById('file-progress-container').classList.add('hidden');
                    this.state.files['current'] = null;
                }
            },

            // --- 6. MEDIA ---

            async toggleVideo() {
                if (!this.state.localStream) await this.startMedia();
                const trk = this.state.localStream.getVideoTracks()[0];
                trk.enabled = !trk.enabled;
                document.getElementById('btn-video').classList.toggle('text-nexus-neon');
            },
            async toggleAudio() {
                if (!this.state.localStream) await this.startMedia();
                const trk = this.state.localStream.getAudioTracks()[0];
                trk.enabled = !trk.enabled;
                document.getElementById('btn-audio').classList.toggle('text-nexus-neon');
            },
            async startMedia() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    this.state.localStream = stream;
                    document.getElementById('local-video').srcObject = stream;
                    document.getElementById('video-grid').classList.remove('hidden');
                    document.getElementById('video-grid').classList.add('flex');
                    if (this.state.conn) {
                         const call = this.state.peer.call(this.state.conn.peer, stream);
                         this.handleMediaCall(call);
                    }
                } catch(e) { alert("Camera access denied"); }
            },
            handleIncomingCall(call) {
                navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) => {
                    this.state.localStream = stream;
                    document.getElementById('local-video').srcObject = stream;
                    document.getElementById('video-grid').classList.remove('hidden');
                    document.getElementById('video-grid').classList.add('flex');
                    call.answer(stream);
                    this.handleMediaCall(call);
                });
            },
            handleMediaCall(call) {
                this.state.call = call;
                call.on('stream', (remoteStream) => {
                    let remoteVideo = document.getElementById('remote-video');
                    if (!remoteVideo) {
                        const container = document.createElement('div');
                        container.className = 'video-container w-48 border border-nexus-purple';
                        container.innerHTML = `<video id="remote-video" autoplay playsinline></video><div class="absolute bottom-1 left-1 text-xs bg-black/70 px-1 text-nexus-purple">REMOTE</div>`;
                        document.getElementById('video-grid').appendChild(container);
                        remoteVideo = container.querySelector('video');
                    }
                    remoteVideo.srcObject = remoteStream;
                });
            },

            // --- UTILS ---
            updateStatus(online) {
                const el = document.getElementById('connection-status');
                el.className = online ? "w-3 h-3 rounded-full bg-nexus-success shadow-[0_0_10px_#00ff9d]" : "w-3 h-3 rounded-full bg-red-500 shadow-[0_0_10px_red]";
            },
            addSidebarUser(nick) {
                const list = document.getElementById('user-list');
                const div = document.createElement('div');
                div.className = 'flex items-center gap-2 p-2 rounded bg-white/5 border border-white/10';
                div.innerHTML = `<div class="w-2 h-2 rounded-full bg-nexus-success"></div><span class="text-white">${this.escapeHtml(nick)}</span>`;
                if(list.innerText.includes("Waiting")) list.innerHTML = '';
                list.appendChild(div);
            },
            updateProgressBar(current, total) {
                const percent = Math.floor((current / total) * 100);
                document.getElementById('file-bar').style.width = `${percent}%`;
                document.getElementById('file-percent').innerText = `${percent}%`;
            },
            escapeHtml(text) {
                const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
                return text.replace(/[&<>"']/g, function(m) { return map[m]; });
            },
            arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) { binary += String.fromCharCode(bytes[i]); }
                return window.btoa(binary);
            },
            base64ToArrayBuffer(base64) {
                const binary_string = window.atob(base64);
                const len = binary_string.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); }
                return bytes.buffer;
            }
        };

        window.Nexus = Nexus;
    </script>
</body>
</html>


