import { insertSignal } from '.crypto.js';
import { receiveAndDecryptFile } from './ not JSON and not channel-encrypted; check for our file-transfer payloads
        try{
          if(typeof ev.data === 'string' && (ev.data.startsWith('ENC:') || ev.data.startsWith('RAW:'))){
            const blob = await receiveAndDecryptFile(ev.data);
            onMessage && onMessage({ type: 'file-full', from: peerId, blob });
            return;
          }
        }catch(ee){ console.warn('dc file decrypt', ee); }
        console.warn('dc decrypt', e); return; }
    }
    if(data && data.type==='chat'){ onMessage && onMessage(data); }
    if(data && data.type==='file-chunk'){ onMessage && onMessage(data); }
  };
  peers[peerId].dc = dc;
}

export async function handleSignalRow(row, roomStorageId, keys, localStream, onMessage){
  try {
    const payload = JSON.parse(row.payload);
    if(payload.type==='enc' && payload.body){
      let dec;
      try { dec = await crypto.aesDecryptRaw(keys.signal, payload.body); } catch(e){ return; }
      if(dec.type==='sdp-offer' && dec.to===window._ultra_runtime.localId){
        await ensurePeer(dec.from, false, localStream, roomStorageId, keys, onMessage);
        const pc = peers[dec.from].pc;
        await pc.setRemoteDescription(dec.sdp);
        const ans = await pc.createAnswer();
        await pc.setLocalDescription(ans);
        const r = { type:'sdp-answer', from: window._ultra_runtime.localId, to: dec.from, sdp: pc.localDescription };
        const enc = await crypto.aesEncryptRaw(keys.signal, r);
        await insertSignal(roomStorageId, { type:'enc', from: window._ultra_runtime.localId, to: dec.from, body: enc });
      } else if(dec.type==='sdp-answer' && dec.to===window._ultra_runtime.localId){
        if(peers[dec.from]) peers[dec.from].pc.setRemoteDescription(dec.sdp);
      } else if(dec.type==='ice' && dec.to===window._ultra_runtime.localId){
        if(peers[dec.from]) try{ await peers[dec.from].pc.addIceCandidate(dec.candidate); } catch(e){ console.warn(e); }
      }
    }
  } catch(e){ console.warn('handleSignalRow', e); }
}