 async function makeSessionQRPayload(room, saltB64u, pubKeyBytes){ return { v:1, room, salt:saltB64u, pub: pubKeyBytes ? base64UrlEncode(pubKeyBytes) : "_b64_", ts: Math.floor(Date.now()/1000) }; } async function signQRPayload(payload){ if(!window.__CIPHERNEXUS_AES_KEY) return "_b64_"; const enc=new TextEncoder(); const _v2298=enc.encode(JSON.stringify(payload)); const sig=await crypto.subtle.sign({name:"_b64_SE1BQw==", hash:"_b64_U0hBLTI1Ng=="}, window.__CIPHERNEXUS_AES_KEY, _v2298); return base64UrlEncode(new Uint8Array(sig)); } function compressQRString(s){ return btoa(unescape(encodeURIComponent(s))); } function renderRealQR(qrStr){ const el=document.createElement("_b64_ZGl2"); el.style.display="_b64_bm9uZQ=="; document.body.appendChild(el); new QRCode(el,{text:qrStr, width:160, height:160, correctLevel:QRCode.CorrectLevel.M}); const img=el.querySelector("_b64_aW1n"); if(img){ const canvas=document.getElementById("_b64_cXJDYW52YXM="); const ctx=canvas.getContext("_b64_MmQ="); const tmp=new Image(); tmp.onload=()=>{ ctx.drawImage(tmp,0,0,160,160); document.body.removeChild(el); }; tmp.src=img.src; } else document.body.removeChild(el); } async function exportAESKey(){ if(!window.__CIPHERNEXUS_AES_KEY){ alert("_b64_Tm8gQUVTIGtleS4="); return; } const raw=await crypto.subtle.exportKey("_b64_cmF3", window.__CIPHERNEXUS_AES_KEY); const arr=new Uint8Array(raw); const b64=btoa(String.fromCharCode(...arr)); const blob=new Blob([b64],{type:"_b64_dGV4dC9wbGFpbg=="}); const url=URL.createObjectURL(blob); const a=document.createElement("_b64_YQ=="); a.href=url; a.download="_b64_Y2lwaGVybmV4dXMta2V5LnR4dA=="; a.click(); URL.revokeObjectURL(url); } async function importAESKeyFromFile(file){ const text=await file.text(); const bytes=Uint8Array.from(atob(text.trim()),c=>c.charCodeAt(0)); const _v2350=await crypto.subtle.importKey( "_b64_cmF3",bytes,{name:"_b64_QUVTLUdDTQ=="},true,["_b64_ZW5jcnlwdA==","_b64_ZGVjcnlwdA=="] ); window.__CIPHERNEXUS_AES_KEY=_v2350; console.log("_b64_QUVTIGtleSBpbXBvcnRlZA=="); } import * as cryptoMod from './crypto.js'; const $ = (id)=>document.getElementById(id); const roomInput = $('roomCode'); const deriveBtn = $('deriveBtn'); const encryptBtn = $('encryptBtn'); const decryptBtn = $('decryptBtn'); const plaintext = $('plaintext'); const result = $('result'); let session = { _v2350: null, salt: null }; deriveBtn.addEventListener('click', async ()=>{ const pass = roomInput.value || prompt('Enter a room code / password:'); if(!pass) return alert('Password required'); result.textContent = 'Deriving _v2350 (Argon2 + HKDF) â€” this may take a moment...'; try{ const r = await cryptoMod.deriveAesKeyFromPassword(pass); session._v2350 = r._v2350; session.salt = r.salt; try{ window.__CIPHERNEXUS_AES_KEY = session._v2350; }catch(e){console.warn('Could not set global AES _v2350',e)} result.textContent = 'Key derived. Salt (base64): ' + session.salt; }catch(e){ console.error(e); result.textContent = 'Derivation failed: ' + e.message; } }); encryptBtn.addEventListener('click', async ()=>{ if(!session._v2350) return alert('Derive a _v2350 first (click Derive & Test)'); try{ const ct = await cryptoMod.encryptString(session._v2350, plaintext.value || ''); result.textContent = 'Ciphertext (base64):\\n' + ct; }catch(e){ console.error(e); result.textContent = 'Encrypt failed: ' + e.message; } }); decryptBtn.addEventListener('click', async ()=>{ if(!session._v2350) return alert('Derive a _v2350 first (click Derive & Test)'); const payload = prompt('Paste base64 payload to decrypt (iv+cipher)'); if(!payload) return; try{ const pt = await cryptoMod.decryptString(session._v2350, payload.trim()); result.textContent = 'Plaintext:\\n' + pt; }catch(e){ console.error(e); result.textContent = 'Decrypt failed: ' + e.message; } }); async function exportAESKey(){ try{ if(!window.__CIPHERNEXUS_AES_KEY){ alert('No _v2350 derived'); return; } const raw = await crypto.subtle.exportKey('raw', window.__CIPHERNEXUS_AES_KEY); const b64 = btoa(String.fromCharCode(...new Uint8Array(raw))); const blob = new Blob([b64],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='ciphernexus-_v2350.txt'; a.click(); URL.revokeObjectURL(url); }catch(e){console.error(e)} } async function importAESKeyFromFile(file){ try{ const text = await file.text(); const bytes = Uint8Array.from(atob(text.trim()), c=>c.charCodeAt(0)); const _v2350 = await crypto.subtle.importKey('raw', bytes, {name:'AES-GCM'}, true, ['encrypt','decrypt']); window.__CIPHERNEXUS_AES_KEY = _v2350; alert('Key imported'); }catch(e){console.error(e); alert('Import failed') } } function base64UrlEncode(bytes){ const b64 = btoa(String.fromCharCode(...new Uint8Array(bytes))); return b64.replace(/\+/g,'-').replace(/\ function base64UrlDecode(b64u){ b64u = b64u.replace(/-/g,'+').replace(/_/g,'/'); while(b64u.length%4) b64u += '='; const str = atob(b64u); return Uint8Array.from(str, c=>c.charCodeAt(0)); } function makeSessionLink(roomCode, saltB64u){ const p = encodeURIComponent(roomCode + ':' + saltB64u); return location.origin + location.pathname + '#session=' + p; } function renderSessionQR(text){ try{ const canvas = document.getElementById('qrCanvas'); if(!canvas) return; const ctx = canvas.getContext('2d'); ctx.fillStyle='#021022'; ctx.fillRect(0,0,canvas.width, canvas.height); ctx.fillStyle='#a6d0f0'; ctx.font='10px monospace'; ctx.textAlign='center'; ctx.fillText('Session:', canvas.width/2, 20); const lines = text.match(/.{1,20}/g)||[text]; for(let i=0;i<lines.length;i++) ctx.fillText(lines[i], canvas.width/2, 40 + i*12); }catch(e){console.warn('qr render',e)} } document.addEventListener('DOMContentLoaded', ()=>{ const exportBtn = document.getElementById('exportKeyBtn'); const importBtn = document.getElementById('importKeyBtn'); const importFile = document.getElementById('importKeyFile'); const drop = document.getElementById('dropZone'); const copyBtn = document.getElementById('copySessionBtn'); const sessionInput = document.getElementById('sessionLink'); const progressWrap = document.getElementById('fileProgressWrap'); const progressBar = document.getElementById('fileProgressBar'); const progressLabel = document.getElementById('fileProgressLabel'); exportBtn && (exportBtn.onclick = exportAESKey); importBtn && (importBtn.onclick = ()=> importFile.click()); importFile && (importFile.onchange = (ev)=> { if(ev.target.files && ev.target.files[0]) importAESKeyFromFile(ev.target.files[0]); }); if(drop){ drop.addEventListener('click', ()=>{ const ip = document.createElement('input'); ip.type='file'; ip.onchange = async (e)=>{ if(e.target.files[0]) await handleFileSend(e.target.files[0]); }; ip.click(); }); drop.addEventListener('dragover', (e)=>{ e.preventDefault(); drop.classList.add('dragover'); }); drop.addEventListener('dragleave', (e)=>{ e.preventDefault(); drop.classList.remove('dragover'); }); drop.addEventListener('drop', async (e)=>{ e.preventDefault(); drop.classList.remove('dragover'); if(e.dataTransfer.files && e.dataTransfer.files[0]) await handleFileSend(e.dataTransfer.files[0]); }); } async function handleFileSend(file){ try{ progressWrap.style.display='block'; progressLabel.textContent = 'Encrypting...'; progressBar.style.width = '10%'; if(window.__CIPHERNEXUS_AES_KEY && typeof window.sendEncryptedFile === 'function'){ progressLabel.textContent = 'Sending encrypted (single message)...'; progressBar.style.width = '60%'; await window.sendEncryptedFile(file, window.__CIPHERNEXUS_SENDFUNC || (payload=>{ console.warn('No send function'); })); progressBar.style.width = '100%'; progressLabel.textContent = 'Sent'; setTimeout(()=>{ progressWrap.style.display='none'; progressBar.style.width='0%'; }, 800); } else { progressLabel.textContent = 'Fallback upload (chunked)'; progressBar.style.width='30%'; if(window.sendFileChunkFallback) await window.sendFileChunkFallback(file, (p)=>{ progressBar.style.width = p + '%'; }); progressBar.style.width='100%'; progressLabel.textContent = 'Uploaded'; setTimeout(()=>{ progressWrap.style.display='none'; progressBar.style.width='0%'; }, 800); } }catch(e){ console.error(e); alert('Send failed'); progressWrap.style.display='none'; } } const roomInput = document.getElementById('roomCode'); const deriveBtn = document.getElementById('deriveBtn'); if(deriveBtn && roomInput){ deriveBtn.addEventListener('click', async ()=>{ const pass = roomInput.value || prompt('Enter room code / password:'); if(!pass) return; const r = await window.cryptoMod?.deriveAesKeyFromPassword?.(pass) || (await (async ()=>{ const o = await window.cryptoMod.deriveAesKeyFromPassword(pass); return o; })()); const saltB64 = r && r.salt ? r.salt : ''; const saltB64u = saltB64 ? saltB64.replace(/\+/g,'-').replace(/\ const link = makeSessionLink(pass, saltB64u); sessionInput.value = link; renderSessionQR(link); }); } copyBtn && (copyBtn.onclick = ()=>{ if(sessionInput.value){ navigator.clipboard?.writeText(sessionInput.value).then(()=>alert('Copied')); } }); }); async function startQRScanner(){ const modal=document.getElementById("_b64_cXJTY2FuTW9kYWw="); modal.style.display="_b64_ZmxleA=="; const video=document.getElementById("_b64_cXJWaWRlbw=="); const status=document.getElementById("_b64_cXJTY2FuU3RhdHVz"); try{ const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"_b64_ZW52aXJvbm1lbnQ="}}); video.srcObject=stream; const canvas=document.createElement("_b64_Y2FudmFz"); const ctx=canvas.getContext("_b64_MmQ="); const scanLoop=()=>{ if(video.readyState===video.HAVE_ENOUGH_DATA){ canvas.width=video.videoWidth; canvas.height=video.videoHeight; ctx.drawImage(video,0,0,canvas.width,canvas.height); const imgData=ctx.getImageData(0,0,canvas.width,canvas.height); const code=window.jsQR(imgData._v2298, canvas.width, canvas.height); if(code){ status.textContent="_b64_UVIgZGV0ZWN0ZWQh"; stopQRScanner(); processQRString(code._v2298); return; } } requestAnimationFrame(scanLoop); }; requestAnimationFrame(scanLoop); }catch(e){ status.textContent="_b64_Q2FtZXJhIGVycm9y"; } } function stopQRScanner(){ const modal=document.getElementById("_b64_cXJTY2FuTW9kYWw="); modal.style.display="_b64_bm9uZQ=="; const video=document.getElementById("_b64_cXJWaWRlbw=="); if(video.srcObject){ video.srcObject.getTracks().forEach(t=>t.stop()); video.srcObject=null; } } document.getElementById("_b64_cXJTY2FuU3RvcA==").onclick=stopQRScanner; document.getElementById("_b64_cXJTY2FuSW1hZ2U=").onclick=()=>document.getElementById("_b64_cXJJbWFnZUZpbGU=").click(); document.getElementById("_b64_cXJJbWFnZUZpbGU=").onchange=async(e)=>{ if(!e.target.files[0])return; const img=new Image(); img.onload=()=>{ const canvas=document.createElement("_b64_Y2FudmFz"); const ctx=canvas.getContext("_b64_MmQ="); canvas.width=img.width; canvas.height=img.height; ctx.drawImage(img,0,0); const _v2298=ctx.getImageData(0,0,canvas.width,canvas.height); const code=window.jsQR(_v2298._v2298, canvas.width, canvas.height); if(code) processQRString(code._v2298); else alert("_b64_Tm8gUVIgZm91bmQ="); }; img.src=URL.createObjectURL(e.target.files[0]); }; async function processQRString(qr){ try{ const payloadStr=decodeURIComponent(atob(qr)); const _v7234=JSON.parse(payloadStr); alert("_b64_UVIgbG9hZGVkOiBSb29tPQ=="+_v7234.room+"_b64_IFNhbHQ9"+_v7234.salt); }catch(e){ console.error(e); alert("_b64_SW52YWxpZCBRUg=="); } } import LZString from "_b64_Li9saWIvY29tcHJlc3Npb24vbHotc3RyaW5nLmpz"; import { verifyHMAC } from "_b64_Li9jcnlwdG8uanM="; _v6649.handleScannedQR = async function(raw){ try{ let dec = LZString.decompressFromUTF16(raw) || raw; const _v7234 = JSON.parse(dec); const core = JSON.stringify({ v:_v7234.v, room:_v7234.room, salt:_v7234.salt, pub:_v7234.pub, ts:_v7234.ts }); if(_v7234.sig){ const ok = await verifyHMAC(_v6649.hmacKey, core, _v7234.sig); if(!ok){ alert("_b64_SW52YWxpZCBRUiBzaWduYXR1cmU="); return; } } document.getElementById("_b64_cm9vbUlucHV0").value = _v7234.room; if(_v7234.pub){ _v6649.remotePub = _v7234.pub; } _v6649.joinRoom(_v7234.room); }catch(e){ console.error(e); } }; import LZString from "_b64_Li9saWIvY29tcHJlc3Npb24vbHotc3RyaW5nLmpz"; import { verifyHMAC } from "_b64_Li9jcnlwdG8uanM="; _v6649.generateSessionQR = async function(){ const room = document.getElementById("_b64_cm9vbUlucHV0").value.trim(); const pub = _v6649.localPub || "_b64_"; const salt = _v6649.salt || "_b64_"; const ts = Date.now(); const payloadCore = { v:1, room, salt, pub, ts }; const coreStr = JSON.stringify(payloadCore); let sigB64 = "_b64_"; if(_v6649.hmacKey){ const sigBuf = await crypto.subtle.sign("_b64_SE1BQw==", _v6649.hmacKey, new TextEncoder().encode(coreStr)); sigB64 = btoa(String.fromCharCode(...new Uint8Array(sigBuf))); } const full = JSON.stringify({...payloadCore, sig: sigB64 }); const compressed = LZString.compressToUTF16(full); _v6649.lastQRPayload = compressed; return compressed; }; 

// Phase8: generate/import local ECDH keypair and persist private key
async function ensureLocalKeyPair(){
  try{
    if(localStorage.getItem('cn_priv')){
      const privB64 = localStorage.getItem('cn_priv');
      const privKey = await importPrivateKeyPkcs8(privB64);
      // export public from private? We need public separately; assume stored as cn_pub
      const pubB64 = localStorage.getItem('cn_pub');
      app.localPrivKey = privKey;
      app.localPub = pubB64;
      return;
    } else {
      const kp = await generateLocalKeyPair();
      if(kp.privatePkcs8){
        localStorage.setItem('cn_priv', kp.privatePkcs8);
      }
      if(kp.publicB64){
        localStorage.setItem('cn_pub', kp.publicB64);
        app.localPub = kp.publicB64;
      }
      app.localPrivKey = await importPrivateKeyPkcs8(localStorage.getItem('cn_priv'));
      return;
    }
  }catch(e){console.warn('keypair error',e);}
}

// call on startup (non-blocking)
ensureLocalKeyPair();

// when handling scanned QR, if peer pub exists derive shared keys and set AES/HMAC
const oldHandle = app.handleScannedQR;
app.handleScannedQR = async function(raw){
  try{
    await oldHandle.call(app, raw);
    // parse JSON after decompression if needed
    let payload = raw;
    try{ payload = JSON.parse(raw); }catch(e){ try{ payload = JSON.parse(LZString.decompressFromUTF16(raw)); }catch(e){} }
    const obj = payload && payload.room ? payload : JSON.parse(payload);
    if(obj.pub && app.localPrivKey){
      const keys = await deriveSharedAESKeys(app.localPrivKey, obj.pub);
      app.hmacKey = keys.hmacKey;
      window.__CIPHERNEXUS_AES_KEY = keys.aesKey;
      console.log('Derived shared AES/HMAC keys from QR pubkey');
    }
  }catch(e){ console.error(e); }
};


// IndexedDB helpers for storing CryptoKey (structured clone supported in modern browsers)
function openDB(){ return new Promise((res,rej)=>{ const req=indexedDB.open('CipherNexusDB',1); req.onupgradeneeded = ()=>{ req.result.createObjectStore('keys'); }; req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); }); }
async function idbPut(key, val){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction('keys','readwrite'); tx.objectStore('keys').put(val,key); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error); }); }
async function idbGet(key){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction('keys','readonly'); const req=tx.objectStore('keys').get(key); req.onsuccess=()=>res(req.result); req.onerror=()=>rej(req.error); }); }

// modify ensureLocalKeyPair to use IndexedDB and non-extractable keys
async function ensureLocalKeyPair(){
  try{
    const stored = await idbGet('cn_keypair');
    if(stored && stored.publicB64 && stored.privateExists){
      // try to import private from stored pkcs8 if present (fallback)
      if(stored.privatePkcs8){
        try{ const priv = await importPrivateKeyPkcs8(stored.privatePkcs8); app.localPrivKey=priv; app.localPub=stored.publicB64; return; }catch(e){ console.warn('private import fail',e); }
      }
    }
    // generate non-extractable keypair
    const kp = await crypto.subtle.generateKey({name:'ECDH', namedCurve:'P-256'}, false, ['deriveBits']);
    const pub = await crypto.subtle.exportKey('raw', kp.publicKey);
    const pubB64 = btoa(String.fromCharCode(...new Uint8Array(pub)));
    app.localPrivKey = kp.privateKey;
    app.localPub = pubB64;
    await idbPut('cn_keypair', { publicB64:pubB64, privateExists:true });
    return;
  }catch(e){ console.warn('ensure keypair',e); }
}
ensureLocalKeyPair();