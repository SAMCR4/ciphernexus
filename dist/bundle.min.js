crypto.js â€” browser-only, uses argon2 from CDN and WebCrypto AES-GCM import argon2 from '.argon2lib and uncomment the local import below. import argon2 from '.argon2* Strategy: - Use Argon2id to hash the password and produce raw bytes. - Use HKDF (SHA-256) with the argon2 output as IKM to derive a 256-bit AES-GCM _v2350. - Encrypt const enc = new TextEncoder(); const dec = new TextDecoder(); async function argon2Hash(pass, saltBytes) { argon2-browser's hash returns encoded and rawHash depending on options const res = await argon2.hash({ pass: typeof pass === 'string' ? enc.encode(pass) : pass, salt: saltBytes, time: 2, mem: 65536, hashLen: 32, parallelism: 1, type: argon2.ArgonType.Argon2id }); res.hash is base64 string; res.hashRaw should be Uint8Array if available if (res.hashRaw) return res.hashRaw; fallback: decode res.hash (base64) return Uint8Array.from(atob(res.hash).split('').map(c=>c.charCodeAt(0))); } async function hkdfExtractAndExpand(ikm, info = new Uint8Array([]), length = 32) { HKDF-SHA256: import ikm as raw _v2350, then deriveKey with HKDF const _v2350 = await crypto.subtle.importKey('raw', ikm, 'HKDF', false, ['deriveKey']); const derived = await crypto.subtle.deriveKey( { name: 'HKDF', hash: 'SHA-256', info: info, salt: new Uint8Array([]) }, _v2350, { name: 'AES-GCM', length: 256}, true, ['encrypt','decrypt'] ); return derived; } export async function deriveAesKeyFromPassword(password, saltStr = null) { salt: if not provided, use random 16 bytes const salt = saltStr ? enc.encode(saltStr) : crypto.getRandomValues(new Uint8Array(16)); const argon = await argon2Hash(password, salt); const aesKey = await hkdfExtractAndExpand(argon, enc.encode('CipherNexus HKDF v1'), 32); return { _v2350: CryptoKey, salt: base64 } return { _v2350: aesKey, salt: btoa(String.fromCharCode(...salt)) }; } export async function encryptString(aesKey, plaintext) { const iv = crypto.getRandomValues(new Uint8Array(12)); 96-bit IV recommended const pt = enc.encode(plaintext); const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, pt); pack iv + cipher as base64 const tmp = new Uint8Array(iv.byteLength + cipher.byteLength); tmp.set(iv, 0); tmp.set(new Uint8Array(cipher), iv.byteLength); return btoa(String.fromCharCode(...tmp)); } export async function decryptString(aesKey, b64payload) { const raw = Uint8Array.from(atob(b64payload), c => c.charCodeAt(0)); const iv = raw.slice(0,12); const cipher = raw.slice(12); const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, cipher); return dec.decode(plain); } helper to import a previously derived _v2350 from jwk / raw for portability export async function exportKeyToRaw(aesKey) { const raw = await crypto.subtle.exportKey('raw', aesKey); return btoa(String.fromCharCode(...new Uint8Array(raw))); } export async function importRawKey(b64raw) { const raw = Uint8Array.from(atob(b64raw), c => c.charCodeAt(0)); return crypto.subtle.importKey('raw', raw, 'AES-GCM', true, ['encrypt','decrypt']); }
--- UI Progress Helpers --- function updateProgress(label, value){ console.log("_b64_UFJPR1JFU1M6", label, value); } function hideProgress(){ console.log("_b64_UHJvZ3Jlc3MgaGlkZGVu"); } --- END UI Progress Helpers --- --- Automatic file encryption helpers (injected) --- const _b64FromBytes = (bytes)=>btoa(String.fromCharCode(...new Uint8Array(bytes))); const _bytesFromB64 = (b64)=>Uint8Array.from(atob(b64), c=>c.charCodeAt(0)); async function encryptBlobForTransfer(blob) { if(!window.__CIPHERNEXUS_AES_KEY) { no _v2350, send raw file as base64 const buf = await blob.arrayBuffer(); return 'RAW:' + _b64FromBytes(new Uint8Array(buf)); } const iv = crypto.getRandomValues(new Uint8Array(12)); const _v2298 = new Uint8Array(await blob.arrayBuffer()); const cipher = await crypto.subtle.encrypt({name:'AES-GCM', iv}, window.__CIPHERNEXUS_AES_KEY, _v2298); const wrapped = new Uint8Array(iv.byteLength + cipher.byteLength); wrapped.set(iv,0); wrapped.set(new Uint8Array(cipher), iv.byteLength); return 'ENC:' + _b64FromBytes(wrapped); } async function decryptBlobFromTransfer(payload) { if(payload.startsWith('RAW:')) { const b = _bytesFromB64(payload.slice(4)); return new Blob([b]); } if(!payload.startsWith('ENC:')) throw new Error('Invalid payload'); const b = _bytesFromB64(payload.slice(4)); const iv = b.slice(0,12); const cipher = b.slice(12); if(!window.__CIPHERNEXUS_AES_KEY) throw new Error('No AES _v2350 available to decrypt file'); const plain = await crypto.subtle.decrypt({name:'AES-GCM', iv}, window.__CIPHERNEXUS_AES_KEY, cipher); return new Blob([new Uint8Array(plain)]); } --- end injection --- import * as crypto from '.storage.js'; export async function sendFileOverDC(dc, file, keys, roomStorageId){ const chunkSize = 64 * 1024; const fileId = 'f_' + Math.random().toString(36).slice(2,9); const total = Math.ceil(file.size Blob through existing send function export async function sendEncryptedFile(blob, sendFunc) { const payload = await encryptBlobForTransfer(blob); sendFunc should accept a string or an ArrayBuffer; we'll send string return sendFunc(payload); } Helper to receive payload string and obtain Blob export async function receiveAndDecryptFile(payload) { return decryptBlobFromTransfer(payload); } expose global helper for UI to call window.sendEncryptedFile = async function(blob, sendFunc){ return await typeof exports !== 'undefined' && exports.sendEncryptedFile ? exports.sendEncryptedFile ? (await exports.sendEncryptedFile(blob, sendFunc)) : (await sendEncryptedFile(blob, sendFunc)); }; window.__CIPHERNEXUS_SENDFUNC = window.__CIPHERNEXUS_SENDFUNC || function(payload){ console.warn('No send function set for CipherNexus'); };
import { insertSignal } from '.crypto.js'; import { receiveAndDecryptFile } from './ not JSON and not channel-encrypted; check for our file-transfer payloads try{ if(typeof ev._v2298 === 'string' && (ev._v2298.startsWith('ENC:') || ev._v2298.startsWith('RAW:'))){ const blob = await receiveAndDecryptFile(ev._v2298); onMessage && onMessage({ type: 'file-full', from: peerId, blob }); return; } }catch(ee){ console.warn('dc file decrypt', ee); } console.warn('dc decrypt', e); return; } } if(_v2298 && _v2298.type==='chat'){ onMessage && onMessage(_v2298); } if(_v2298 && _v2298.type==='file-chunk'){ onMessage && onMessage(_v2298); } }; peers[peerId].dc = dc; } export async function handleSignalRow(row, roomStorageId, keys, localStream, onMessage){ try { const payload = JSON.parse(row.payload); if(payload.type==='enc' && payload.body){ let dec; try { dec = await crypto.aesDecryptRaw(keys.signal, payload.body); } catch(e){ return; } if(dec.type==='sdp-offer' && dec.to===window._ultra_runtime.localId){ await ensurePeer(dec.from, false, localStream, roomStorageId, keys, onMessage); const pc = peers[dec.from].pc; await pc.setRemoteDescription(dec.sdp); const ans = await pc.createAnswer(); await pc.setLocalDescription(ans); const r = { type:'sdp-answer', from: window._ultra_runtime.localId, to: dec.from, sdp: pc.localDescription }; const enc = await crypto.aesEncryptRaw(keys.signal, r); await insertSignal(roomStorageId, { type:'enc', from: window._ultra_runtime.localId, to: dec.from, body: enc }); } else if(dec.type==='sdp-answer' && dec.to===window._ultra_runtime.localId){ if(peers[dec.from]) peers[dec.from].pc.setRemoteDescription(dec.sdp); } else if(dec.type==='ice' && dec.to===window._ultra_runtime.localId){ if(peers[dec.from]) try{ await peers[dec.from].pc.addIceCandidate(dec.candidate); } catch(e){ console.warn(e); } } } } catch(e){ console.warn('handleSignalRow', e); } }
--- AES Key Exportplain"_b64_fSk7IGNvbnN0IHVybD1VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpOyBjb25zdCBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQo"a"_b64_KTsgYS5ocmVmPXVybDsgYS5kb3dubG9hZD0="ciphernexus-_v2350.txt"_b64_OyBhLmNsaWNrKCk7IFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTsgfSBhc3luYyBmdW5jdGlvbiBpbXBvcnRBRVNLZXlGcm9tRmlsZShmaWxlKXsgY29uc3QgdGV4dD1hd2FpdCBmaWxlLnRleHQoKTsgY29uc3QgYnl0ZXM9VWludDhBcnJheS5mcm9tKGF0b2IodGV4dC50cmltKCkpLGM9PmMuY2hhckNvZGVBdCgwKSk7IGNvbnN0IGtleT1hd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgg"raw"_b64_LGJ5dGVzLHtuYW1lOg=="AES-GCM"_b64_fSx0cnVlLFs="encrypt"_b64_LA=="decrypt"_b64_XSApOyB3aW5kb3cuX19DSVBIRVJORVhVU19BRVNfS0VZPWtleTsgY29uc29sZS5sb2co"AES _v2350 imported"); } --- END AES Key Exportcrypto.js'; const $ = (id)=>document.getElementById(id); const roomInput = $('roomCode'); const deriveBtn = $('deriveBtn'); const encryptBtn = $('encryptBtn'); const decryptBtn = $('decryptBtn'); const plaintext = $('plaintext'); const result = $('result'); let session = { _v2350: null, salt: null }; deriveBtn.addEventListener('click', async ()=>{ const pass = roomInput.value || prompt('Enter a room code import keys, drag-drop, session export, QR render --- async function exportAESKey(){ try{ if(!window.__CIPHERNEXUS_AES_KEY){ alert('No _v2350 derived'); return; } const raw = await crypto.subtle.exportKey('raw', window.__CIPHERNEXUS_AES_KEY); const b64 = btoa(String.fromCharCode(...new Uint8Array(raw))); const blob = new Blob([b64],{type:'text\+\g,'_').replace(,''); } function base64UrlDecode(b64u){ b64u = b64u.replace(g,'+').replace(g,'2, 20); const lines = text.match(g)||[text]; for(let i=0;i<lines.length;i++) ctx.fillText(lines[i], canvas.width password:'); if(!pass) return; const r = await window.cryptoMod?.deriveAesKeyFromPassword?.(pass) || (await (async ()=>{ const o = await window.cryptoMod.deriveAesKeyFromPassword(pass); return o; })()); if deriveAesKeyFromPassword returns salt in base64, convert to base64url const saltB64 = r && r.salt ? r.salt : ''; const saltB64u = saltB64 ? saltB64.replace(g,'-').replace(=+$/ --- end UI integration ---